// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Template classes have static data artifcats empty 1`] = `
Object {
  "prisma/seed.js": Object {
    "content": "\\"use strict\\";

Object.defineProperty(exports, \\"__esModule\\", {
  value: true
});
exports.seed = seed;

var _studioPcw = require(\\"@prisma/studio-pcw\\");

const schema = \`PRISMA TEMPLATE: empty\`;
const schemaPath = \\"/tmp/schema.prisma\\";

async function seed() {
  const pcw = new _studioPcw.PCW(schema, schemaPath, {
    PRISMA_CLOUD_PROJECT_DATASOURCE_URL: process.env.PRISMA_CLOUD_PROJECT_DATASOURCE_URL
  }, {
    forcePrismaLibrary: true,
    resolve: {
      \\".prisma/client\\": require.resolve(\\".prisma/client\\")
    }
  });
  const {
    prisma: prisma
  } = await pcw.getPrismaClient();
}

(async () => await seed())()",
    "path": "prisma/seed.js",
  },
}
`;

exports[`Template classes have static data artifcats musicStreamingService 1`] = `
Object {
  "prisma/seed.js": Object {
    "content": "\\"use strict\\";

Object.defineProperty(exports, \\"__esModule\\", {
  value: true
});
exports.seed = seed;

var _studioPcw = require(\\"@prisma/studio-pcw\\");

var faker = _interopRequireWildcard(require(\\"faker\\"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \\"function\\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \\"object\\" && typeof obj !== \\"function\\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \\"default\\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const MAX_NUMBER_OF_SONGS_PER_ARTIST = 5;
const NUMBER_OF_ARTISTS = 5;
const NUMBER_OF_USERS = 10;
const userIds = Array.from({
  length: NUMBER_OF_USERS
}).map(() => faker.datatype.uuid());
const schema = \`PRISMA TEMPLATE: musicStreamingService\`;
const schemaPath = \\"/tmp/schema.prisma\\";

async function seed() {
  const pcw = new _studioPcw.PCW(schema, schemaPath, {
    PRISMA_CLOUD_PROJECT_DATASOURCE_URL: process.env.PRISMA_CLOUD_PROJECT_DATASOURCE_URL
  }, {
    forcePrismaLibrary: true,
    resolve: {
      \\".prisma/client\\": require.resolve(\\".prisma/client\\")
    }
  });
  const {
    prisma: prisma
  } = await pcw.getPrismaClient();

  try {
    // Create artists
    await prisma.artist.createMany({
      data: Array.from({
        length: NUMBER_OF_ARTISTS
      }).map(() => ({
        name: faker.name.firstName()
      }))
    });
    const artists = await prisma.artist.findMany(); // Create songs for each artist

    for (const artist of artists) {
      await prisma.album.create({
        data: {
          cover: faker.image.imageUrl(),
          name: faker.random.words(2),
          artists: {
            connect: {
              id: artist.id
            }
          },
          songs: {
            create: Array.from({
              length: faker.datatype.number({
                min: 2,
                max: MAX_NUMBER_OF_SONGS_PER_ARTIST
              })
            }).map(() => ({
              artistId: artist.id,
              fileUrl: faker.internet.url(),
              length: faker.datatype.float(),
              name: faker.name.firstName()
            }))
          }
        }
      });
    } // Create songs


    const songs = await prisma.song.findMany();

    for (const userId of userIds) {
      // Create users
      await prisma.user.create({
        data: {
          id: userId,
          email: faker.internet.email(),
          name: faker.name.firstName(),
          interactions: {
            create: Array.from({
              length: faker.datatype.number({
                min: 3,
                max: songs.length
              })
            }).map(() => ({
              playCount: faker.datatype.number({
                min: 1,
                max: 1000
              }),
              songId: songs[faker.datatype.number({
                min: 0,
                max: songs.length - 1
              })].id,
              // random boolean
              isLiked: Math.random() < 0.5
            }))
          }
        }
      }); // Create Playlists

      await prisma.playlist.create({
        data: {
          name: faker.random.words(2),
          user: {
            connect: {
              id: userId
            }
          },
          // each playlist will have a random list of songs
          songs: {
            connect: songs.slice(0, faker.datatype.number({
              min: 1,
              max: songs.length - 1
            })).map(({
              id
            }) => ({
              id
            }))
          }
        }
      });
    }
  } catch (e) {
    await prisma.$disconnect();
    throw e;
  } finally {
    await prisma.$disconnect();
  }
}

(async () => await seed())()",
    "path": "prisma/seed.js",
  },
}
`;

exports[`Template classes have static data artifcats rentalsPlatform 1`] = `
Object {
  "prisma/seed.js": Object {
    "content": "\\"use strict\\";

Object.defineProperty(exports, \\"__esModule\\", {
  value: true
});
exports.seed = seed;

var _studioPcw = require(\\"@prisma/studio-pcw\\");

var faker = _interopRequireWildcard(require(\\"faker\\"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \\"function\\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \\"object\\" && typeof obj !== \\"function\\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \\"default\\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const NUMBER_OF_USERS = 10;
const NUMBER_OF_ROOMS = 20;
const roomIds = Array.from({
  length: NUMBER_OF_ROOMS
}).map(() => faker.datatype.uuid());
const rooms = Array.from({
  length: NUMBER_OF_ROOMS
}).map((_, i) => ({
  id: roomIds[i],
  price: faker.datatype.number({
    min: 50,
    max: 600
  }),
  // random address - example: b-365
  address: \`\${faker.address.streetPrefix()}-\${faker.datatype.number({
    min: 300,
    max: 1
  })}\`,
  totalOccupancy: faker.datatype.number({
    min: 1,
    max: 5
  }),
  totalBedrooms: faker.datatype.number({
    min: 1,
    max: 5
  }),
  totalBathrooms: faker.datatype.number({
    min: 1,
    max: 5
  }),
  summary: faker.lorem.paragraph(),
  media: Array.from({
    length: faker.datatype.number({
      min: 1,
      max: 5
    })
  }).map(() => ({
    fileName: faker.image.imageUrl()
  }))
}));
const data = Array.from({
  length: NUMBER_OF_USERS
}).map(() => ({
  email: faker.internet.email(),
  name: faker.name.firstName(),
  reviews: Array.from({
    length: faker.datatype.number({
      max: 1,
      min: 4
    })
  }).map(() => ({
    comment: faker.lorem.paragraph(),
    rating: faker.datatype.number({
      max: 1,
      min: 5
    })
  })),
  // create random reservations per user
  reservations: Array.from({
    length: faker.datatype.number({
      min: 1,
      max: 4
    })
  }).map(() => {
    const startDate = faker.date.past();
    const endDate = faker.date.future();
    const price = faker.datatype.number({
      min: 50,
      max: 600
    });
    return {
      startDate,
      endDate,
      price,
      total: Math.ceil(Math.abs(+endDate - +startDate) / (1000 * 60 * 60 * 24)) * price,
      // difference between dates * price
      room: {
        connect: {
          id: roomIds[faker.datatype.number({
            min: 0,
            max: NUMBER_OF_ROOMS - 1
          })]
        }
      }
    };
  })
}));
const schema = \`PRISMA TEMPLATE: rentalsPlatform\`;
const schemaPath = \\"/tmp/schema.prisma\\";

async function seed() {
  const pcw = new _studioPcw.PCW(schema, schemaPath, {
    PRISMA_CLOUD_PROJECT_DATASOURCE_URL: process.env.PRISMA_CLOUD_PROJECT_DATASOURCE_URL
  }, {
    forcePrismaLibrary: true,
    resolve: {
      \\".prisma/client\\": require.resolve(\\".prisma/client\\")
    }
  });
  const {
    prisma: prisma
  } = await pcw.getPrismaClient();

  try {
    rooms.forEach(async room => await prisma.room.create({
      data: {
        id: room.id,
        address: room.address,
        price: room.price,
        summary: room.summary,
        media: {
          create: room.media
        }
      }
    }));

    for (let entry of data) {
      await prisma.user.create({
        data: {
          email: entry.email,
          name: entry.name,
          reservations: {
            create: entry.reservations
          },
          reviews: {
            create: entry.reviews
          }
        }
      });
    }
  } catch (e) {
    await prisma.$disconnect();
    throw e;
  } finally {
    await prisma.$disconnect();
  }
}

(async () => await seed())()",
    "path": "prisma/seed.js",
  },
}
`;

exports[`Template classes have static data artifcats saas 1`] = `
Object {
  "prisma/seed.js": Object {
    "content": "\\"use strict\\";

Object.defineProperty(exports, \\"__esModule\\", {
  value: true
});
exports.seed = seed;

var _studioPcw = require(\\"@prisma/studio-pcw\\");

var faker = _interopRequireWildcard(require(\\"faker\\"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \\"function\\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \\"object\\" && typeof obj !== \\"function\\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \\"default\\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const NUMBER_OF_USERS = 4;
const NUMBER_OF_INVITES = 4;
const data = Array.from({
  length: NUMBER_OF_USERS
}).map(() => ({
  email: faker.internet.email(),
  name: faker.name.firstName(),
  account: {
    stripeCustomerId: faker.datatype.uuid(),
    stripeSubscriptionId: faker.datatype.uuid(),
    isActive: true
  },
  invites: Array.from({
    length: faker.datatype.number({
      min: 0,
      max: NUMBER_OF_INVITES
    })
  }).map(() => ({
    email: faker.internet.email(),
    dateSent: faker.date.future()
  }))
}));
const schema = \`PRISMA TEMPLATE: saas\`;
const schemaPath = \\"/tmp/schema.prisma\\";

async function seed() {
  const pcw = new _studioPcw.PCW(schema, schemaPath, {
    PRISMA_CLOUD_PROJECT_DATASOURCE_URL: process.env.PRISMA_CLOUD_PROJECT_DATASOURCE_URL
  }, {
    forcePrismaLibrary: true,
    resolve: {
      \\".prisma/client\\": require.resolve(\\".prisma/client\\")
    }
  });
  const {
    prisma: prisma
  } = await pcw.getPrismaClient();
  let error;

  try {
    for (let entry of data) {
      await prisma.user.create({
        data: {
          name: entry.name,
          email: entry.email,
          account: {
            create: {
              stripeCustomerId: entry.account.stripeCustomerId,
              stripeSubscriptionId: entry.account.stripeSubscriptionId,
              isActive: true,
              invites: {
                create: entry.invites
              }
            }
          }
        }
      });
    }
  } catch (e) {
    await prisma.$disconnect();
    throw e;
  } finally {
    await prisma.$disconnect();
  }
}

(async () => await seed())()",
    "path": "prisma/seed.js",
  },
}
`;

exports[`Template classes have static data artifcats urlShortener 1`] = `
Object {
  "prisma/seed.js": Object {
    "content": "\\"use strict\\";

Object.defineProperty(exports, \\"__esModule\\", {
  value: true
});
exports.seed = seed;

var _studioPcw = require(\\"@prisma/studio-pcw\\");

var faker = _interopRequireWildcard(require(\\"faker\\"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \\"function\\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \\"object\\" && typeof obj !== \\"function\\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \\"default\\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const NUMBER_OF_USERS = 4;
const MAX_NUMBER_OF_LINKS = 5;
const data = Array.from({
  length: NUMBER_OF_USERS
}).map(() => ({
  email: faker.internet.email(),
  name: faker.name.firstName(),
  links: Array.from({
    length: faker.datatype.number({
      min: 0,
      max: MAX_NUMBER_OF_LINKS
    })
  }).map(() => ({
    url: faker.internet.url(),
    shortUrl: faker.internet.domainWord()
  }))
}));
const schema = \`PRISMA TEMPLATE: urlShortener\`;
const schemaPath = \\"/tmp/schema.prisma\\";

async function seed() {
  const pcw = new _studioPcw.PCW(schema, schemaPath, {
    PRISMA_CLOUD_PROJECT_DATASOURCE_URL: process.env.PRISMA_CLOUD_PROJECT_DATASOURCE_URL
  }, {
    forcePrismaLibrary: true,
    resolve: {
      \\".prisma/client\\": require.resolve(\\".prisma/client\\")
    }
  });
  const {
    prisma: prisma
  } = await pcw.getPrismaClient();

  try {
    for (let entry of data) {
      await prisma.user.create({
        data: {
          name: entry.name,
          email: entry.email,
          links: {
            create: entry.links
          }
        }
      });
    }
  } catch (e) {
    await prisma.$disconnect();
    throw e;
  } finally {
    await prisma.$disconnect();
  }
}

(async () => await seed())()",
    "path": "prisma/seed.js",
  },
}
`;

exports[`Template classes have static data files empty 1`] = `
Object {
  "README.md": Object {
    "content": "# Empty Prisma Project

An empty Prisma Schema with no models, perfect as a starting point for your own schema.",
    "path": "README.md",
  },
  "package.json": Object {
    "content": "{
  \\"name\\": \\"empty\\",
  \\"license\\": \\"UNLICENSED\\",
  \\"devDependencies\\": {
    \\"prisma\\": \\"2.25.0\\"
  },
  \\"dependencies\\": {
    \\"@prisma/client\\": \\"2.25.0\\"
  },
  \\"engines\\": {
    \\"node\\": \\">=10.0.0\\"
  }
}",
    "path": "package.json",
  },
  "prisma/schema.prisma": Object {
    "content": "// An empty Prisma Schema with no models, perfect as a starting point for your own schema.

datasource db {
  provider = \\"postgresql\\"
  url      = env(\\"DATABASE_URL\\")
}

generator client {
  provider = \\"prisma-client-js\\"
}",
    "path": "prisma/schema.prisma",
  },
  "prisma/seed.ts": Object {
    "content": "import { PrismaClient } from \\"@prisma/client\\";

export async function seed() {
  const prisma = new PrismaClient();
}",
    "path": "prisma/seed.ts",
  },
}
`;

exports[`Template classes have static data files musicStreamingService 1`] = `
Object {
  "README.md": Object {
    "content": "# Music Streaming Service

![Database diagram](https://raw.githubusercontent.com/prisma/prisma-schema-examples/main/musicStreamingService/diagram.png)

(Generated via https://github.com/notiz-dev/prisma-dbml-generator + https://dbdiagram.io)

### Setting this project up locally

Once you clone your repo, you'll want to set up this repo for local development. In order to start using Prisma locally, you need to make Prisma aware of your database. The most portable way to do this is to use environment variables via a \`.env\` file.

1. You'll see that your Prisma Schema file (at \`prisma/schema.prisma\`) is already configured to use an environment variable called \`DATABASE_URL\`. [Read more about environment variables in Prisma](https://www.prisma.io/docs/concepts/more/environment-variables)
2. You'll need a database to connect to. You may use the same one you used while setting this project up on the Prisma Data Platform, but we recommend setting up a local database and use that during development. If you're new to databases, we recommend [reading up](https://www.prisma.io/dataguide/) on them. This guide also has instructions on how to set up a local database.
3. Once you have a locally accessible database connection string, create a new file called \`.env\` in the \`prisma\` directory, and populate it with: \`DATABASE_URL=\\"<replace-me-with-your-connection-string>\\"\`. Prisma will automatically pick up the environment variable used in the schema and use its value to connect to your database.
4. Now you can run \`npm run init\` to set up your local database. This will create tables corresponding to models in your Prisma Schema and populate them with fake data for you to play around with.
   - [Read more about the Prisma Schema](https://www.prisma.io/docs/concepts/components/prisma-schema)
   - [Read more about database seeding](https://www.prisma.io/docs/guides/database/seed-database)

To learn more about Prisma, we recommend reading through our [Getting Started guide](https://www.prisma.io/docs/getting-started)",
    "path": "README.md",
  },
  "package.json": Object {
    "content": "{
  \\"name\\": \\"music-streaming-service\\",
  \\"license\\": \\"UNLICENSED\\",
  \\"devDependencies\\": {
    \\"@types/faker\\": \\"5.5.6\\",
    \\"@types/node\\": \\"15.12.5\\",
    \\"faker\\": \\"5.5.3\\",
    \\"prisma\\": \\"2.25.0\\",
    \\"ts-node\\": \\"10.0.0\\",
    \\"typescript\\": \\"4.3.3\\"
  },
  \\"scripts\\": {
    \\"init\\": \\"prisma db push && prisma db seed --preview-feature\\",
    \\"dev\\": \\"ts-node ./script.ts\\"
  },
  \\"dependencies\\": {
    \\"@prisma/client\\": \\"2.25.0\\"
  },
  \\"engines\\": {
    \\"node\\": \\">=12.2.0\\"
  }
}",
    "path": "package.json",
  },
  "prisma/schema.prisma": Object {
    "content": "// Schema for a fictional music streaming service
// This service contains songs, albums, artists & playlists, and tracks user interactions with each of them

datasource db {
  provider = \\"postgresql\\"
  url      = env(\\"DATABASE_URL\\")
}

generator client {
  provider = \\"prisma-client-js\\"
}

model User {
  id           String        @id @default(uuid())
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt
  name         String
  email        String        @unique
  interactions Interaction[]
  playlists    Playlist[]
}

model Interaction {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  songId    String?
  userId    String?
  isLiked   Boolean  @default(false)
  playCount Int
  song      Song?    @relation(fields: [songId], references: [id])
  user      User?    @relation(fields: [userId], references: [id])
}

model Song {
  id           String        @id @default(uuid())
  interactions Interaction[]
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt
  name         String
  album        Album?        @relation(fields: [albumId], references: [id])
  albumId      String?
  artist       Artist        @relation(fields: [artistId], references: [id])
  artistId     String
  length       Float
  track        Int?
  lyrics       String?
  playlist     Playlist[]
  fileUrl      String
}

model Artist {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  name      String
  albums    Album[]
  songs     Song[]
}

model Album {
  id        String   @id @default(uuid())
  songs     Song[]
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  artists   Artist[]
  name      String
  cover     String
}

model Playlist {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  user      User?    @relation(fields: [userId], references: [id])
  userId    String?
  songs     Song[]
  name      String
}",
    "path": "prisma/schema.prisma",
  },
  "prisma/seed.ts": Object {
    "content": "import { PrismaClient } from '@prisma/client'
import * as faker from 'faker'

const MAX_NUMBER_OF_SONGS_PER_ARTIST = 5
const NUMBER_OF_ARTISTS = 5
const NUMBER_OF_USERS = 10

const userIds = Array.from({
  length: NUMBER_OF_USERS,
}).map(() => faker.datatype.uuid())

export async function seed() {
  const prisma = new PrismaClient()

  try {
    // Create artists
    await prisma.artist.createMany({
      data: Array.from({ length: NUMBER_OF_ARTISTS }).map(() => ({
        name: faker.name.firstName(),
      })),
    })

    const artists = await prisma.artist.findMany()

    // Create songs for each artist
    for (const artist of artists) {
      await prisma.album.create({
        data: {
          cover: faker.image.imageUrl(),
          name: faker.random.words(2),
          artists: {
            connect: {
              id: artist.id,
            },
          },
          songs: {
            create: Array.from({
              length: faker.datatype.number({
                min: 2,
                max: MAX_NUMBER_OF_SONGS_PER_ARTIST,
              }),
            }).map(() => ({
              artistId: artist.id,
              fileUrl: faker.internet.url(),
              length: faker.datatype.float(),
              name: faker.name.firstName(),
            })),
          },
        },
      })
    }

    // Create songs
    const songs = await prisma.song.findMany()

    for (const userId of userIds) {
      // Create users
      await prisma.user.create({
        data: {
          id: userId,
          email: faker.internet.email(),
          name: faker.name.firstName(),
          interactions: {
            create: Array.from({
              length: faker.datatype.number({
                min: 3,
                max: songs.length,
              }),
            }).map(() => ({
              playCount: faker.datatype.number({ min: 1, max: 1000 }),
              songId:
                songs[faker.datatype.number({ min: 0, max: songs.length - 1 })]
                  .id,
              // random boolean
              isLiked: Math.random() < 0.5,
            })),
          },
        },
      })

      // Create Playlists
      await prisma.playlist.create({
        data: {
          name: faker.random.words(2),
          user: {
            connect: {
              id: userId,
            },
          },
          // each playlist will have a random list of songs
          songs: {
            connect: songs
              .slice(
                0,
                faker.datatype.number({ min: 1, max: songs.length - 1 }),
              )
              .map(({ id }) => ({ id })),
          },
        },
      })
    }
  } catch (e) {
    await prisma.$disconnect()
    throw e
  } finally {
    await prisma.$disconnect()
  }
}",
    "path": "prisma/seed.ts",
  },
  "script.ts": Object {
    "content": "import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient()

const main = async () => {
  const albums = await prisma.album.findMany({
    where: {
      name: {
        contains: ' '
      }
    }
  })

  console.log('Albums that have more than 1 word: ', albums)
}

main()
  .catch((e) => console.error('Error in Prisma Client query: ', e))
  .finally(async () => await prisma.$disconnect())",
    "path": "script.ts",
  },
  "tsconfig.json": Object {
    "content": "{
  \\"compilerOptions\\": {
    \\"sourceMap\\": true,
    \\"outDir\\": \\"dist\\",
    \\"strict\\": true,
    \\"lib\\": [\\"esnext\\", \\"dom\\"],
    \\"esModuleInterop\\": true
  }
}",
    "path": "tsconfig.json",
  },
}
`;

exports[`Template classes have static data files rentalsPlatform 1`] = `
Object {
  "README.md": Object {
    "content": "# Rentals Platform

![Database Diagram](https://github.com/prisma/prisma-schema-examples/blob/cloud/rentalsPlatform/diagram.png?raw=true)

(Generated via https://github.com/notiz-dev/prisma-dbml-generator + https://dbdiagram.io)

### Setting this project up locally

Once you clone your repo, you'll want to set up this repo for local development. In order to start using Prisma locally, you need to make Prisma aware of your database. The most portable way to do this is to use environment variables via a \`.env\` file.

1. You'll see that your Prisma Schema file (at \`prisma/schema.prisma\`) is already configured to use an environment variable called \`DATABASE_URL\`. [Read more about environment variables in Prisma](https://www.prisma.io/docs/concepts/more/environment-variables)
2. You'll need a database to connect to. You may use the same one you used while setting this project up on the Prisma Data Platform, but we recommend setting up a local database and use that during development. If you're new to databases, we recommend [reading up](https://www.prisma.io/dataguide/) on them. This guide also has instructions on how to set up a local database.
3. Once you have a locally accessible database connection string, create a new file called \`.env\` in the \`prisma\` directory, and populate it with: \`DATABASE_URL=\\"<replace-me-with-your-connection-string>\\"\`. Prisma will automatically pick up the environment variable used in the schema and use its value to connect to your database.
4. Now you can run \`npm run init\` to set up your local database. This will create tables corresponding to models in your Prisma Schema and populate them with fake data for you to play around with.
   - [Read more about the Prisma Schema](https://www.prisma.io/docs/concepts/components/prisma-schema)
   - [Read more about database seeding](https://www.prisma.io/docs/guides/database/seed-database)

To learn more about Prisma, we recommend reading through our [Getting Started guide](https://www.prisma.io/docs/getting-started",
    "path": "README.md",
  },
  "package.json": Object {
    "content": "{
  \\"name\\": \\"rentals-platform\\",
  \\"license\\": \\"UNLICENSED\\",
  \\"devDependencies\\": {
    \\"@types/faker\\": \\"5.5.6\\",
    \\"@types/node\\": \\"15.12.5\\",
    \\"faker\\": \\"5.5.3\\",
    \\"prisma\\": \\"2.25.0\\",
    \\"ts-node\\": \\"10.0.0\\",
    \\"typescript\\": \\"4.3.3\\"
  },
  \\"scripts\\": {
    \\"init\\": \\"prisma db push && prisma db seed --preview-feature\\",
    \\"dev\\": \\"ts-node ./script.ts\\"
  },
  \\"dependencies\\": {
    \\"@prisma/client\\": \\"2.25.0\\"
  },
  \\"engines\\": {
    \\"node\\": \\">=12.2.0\\"
  }
}",
    "path": "package.json",
  },
  "prisma/schema.prisma": Object {
    "content": "// Schema for a fictional hotel
// This hotel tracks rooms, user reservations & reviews

datasource db {
  provider = \\"postgresql\\"
  url      = env(\\"DATABASE_URL\\")
}

generator client {
  provider = \\"prisma-client-js\\"
}

model User {
  id           String        @id @default(uuid())
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt
  email        String        @unique
  name         String
  reservations Reservation[]
  reviews      Review[]
}

model Reservation {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  userId    String?
  user      User?    @relation(fields: [userId], references: [id])
  startDate DateTime
  endDate   DateTime
  price     Int
  total     Int
  room      Room?    @relation(fields: [roomId], references: [id])
  roomId    String?
}

model Room {
  id                 String        @id @default(uuid())
  createdAt          DateTime      @default(now())
  updatedAt          DateTime      @updatedAt
  reservations       Reservation[]
  totalOccupancy     Int           @default(5)
  totalBedrooms      Int           @default(5)
  totalBathrooms     Int           @default(5)
  summary            String?
  address            String
  isSmoking          Boolean       @default(false)
  hasTV              Boolean       @default(true)
  hasAirConditioning Boolean       @default(true)
  hasHeating         Boolean       @default(true)
  hasWIFI            Boolean       @default(true)
  price              Int
  media              Media[]

}

model Review {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  rating    Int
  comment   String
  user      User     @relation(fields: [userId], references: [id])
  userId    String
}

model Media {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  room      Room?    @relation(fields: [roomId], references: [id])
  roomId    String?
  fileName  String
}",
    "path": "prisma/schema.prisma",
  },
  "prisma/seed.ts": Object {
    "content": "import { PrismaClient } from '@prisma/client'
import * as faker from 'faker'

const NUMBER_OF_USERS = 10
const NUMBER_OF_ROOMS = 20

const roomIds = Array.from({
  length: NUMBER_OF_ROOMS,
}).map(() => faker.datatype.uuid())

const rooms = Array.from({
  length: NUMBER_OF_ROOMS,
}).map((_, i) => ({
  id: roomIds[i],
  price: faker.datatype.number({
    min: 50,
    max: 600,
  }),
  // random address - example: b-365
  address: \`\${faker.address.streetPrefix()}-\${faker.datatype.number({
    min: 300,
    max: 1,
  })}\`,
  totalOccupancy: faker.datatype.number({ min: 1, max: 5 }),
  totalBedrooms: faker.datatype.number({ min: 1, max: 5 }),
  totalBathrooms: faker.datatype.number({ min: 1, max: 5 }),
  summary: faker.lorem.paragraph(),
  media: Array.from({
    length: faker.datatype.number({ min: 1, max: 5 }),
  }).map(() => ({
    fileName: faker.image.imageUrl(),
  })),
}))

const data = Array.from({ length: NUMBER_OF_USERS }).map(() => ({
  email: faker.internet.email(),
  name: faker.name.firstName(),
  reviews: Array.from({
    length: faker.datatype.number({
      max: 1,
      min: 4,
    }),
  }).map(() => ({
    comment: faker.lorem.paragraph(),
    rating: faker.datatype.number({
      max: 1,
      min: 5,
    }),
  })),
  // create random reservations per user
  reservations: Array.from({
    length: faker.datatype.number({
      min: 1,
      max: 4,
    }),
  }).map(() => {
    const startDate = faker.date.past()
    const endDate = faker.date.future()
    const price = faker.datatype.number({
      min: 50,
      max: 600,
    })
    return {
      startDate,
      endDate,
      price,
      total:
        Math.ceil(Math.abs(+endDate - +startDate) / (1000 * 60 * 60 * 24)) *
        price, // difference between dates * price
      room: {
        connect: {
          id: roomIds[
            faker.datatype.number({
              min: 0,
              max: NUMBER_OF_ROOMS - 1,
            })
          ],
        },
      },
    }
  }),
}))

export async function seed() {
  const prisma = new PrismaClient()

  try {
    rooms.forEach(
      async (room) =>
        await prisma.room.create({
          data: {
            id: room.id,
            address: room.address,
            price: room.price,
            summary: room.summary,
            media: {
              create: room.media,
            },
          },
        }),
    )

    for (let entry of data) {
      await prisma.user.create({
        data: {
          email: entry.email,
          name: entry.name,
          reservations: {
            create: entry.reservations,
          },
          reviews: {
            create: entry.reviews,
          },
        },
      })
    }
  } catch (e) {
    await prisma.$disconnect()
    throw e
  } finally {
    await prisma.$disconnect()
  }
}",
    "path": "prisma/seed.ts",
  },
  "script.ts": Object {
    "content": "import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient()

const main = async () => {
  const reservations = await prisma.reservation.findMany({
    where: {
      price: {
        gte: 300,
      },
    },
  })

  console.log('Expensive reservations: ', reservations)
}

main()
  .catch((e) => console.error('Error in Prisma Client query: ', e))
  .finally(async () => await prisma.$disconnect())",
    "path": "script.ts",
  },
  "tsconfig.json": Object {
    "content": "{
  \\"compilerOptions\\": {
    \\"sourceMap\\": true,
    \\"outDir\\": \\"dist\\",
    \\"strict\\": true,
    \\"lib\\": [\\"esnext\\", \\"dom\\"],
    \\"esModuleInterop\\": true
  }
}",
    "path": "tsconfig.json",
  },
}
`;

exports[`Template classes have static data files saas 1`] = `
Object {
  "README.md": Object {
    "content": "# SaaS

Generic Prisma schema example for a SaaS that has a referral system.

![Database diagram](https://raw.githubusercontent.com/prisma/prisma-schema-examples/main/saas/diagram.png)

(Generated via https://github.com/notiz-dev/prisma-dbml-generator + https://dbdiagram.io)

### Setting this project up locally

Once you clone your repo, you'll want to set up this repo for local development. In order to start using Prisma locally, you need to make Prisma aware of your database. The most portable way to do this is to use environment variables via a \`.env\` file.

1. You'll see that your Prisma Schema file (at \`prisma/schema.prisma\`) is already configured to use an environment variable called \`DATABASE_URL\`. [Read more about environment variables in Prisma](https://www.prisma.io/docs/concepts/more/environment-variables)
2. You'll need a database to connect to. You may use the same one you used while setting this project up on the Prisma Data Platform, but we recommend setting up a local database and use that during development. If you're new to databases, we recommend [reading up](https://www.prisma.io/dataguide/) on them. This guide also has instructions on how to set up a local database.
3. Once you have a locally accessible database connection string, create a new file called \`.env\` in the \`prisma\` directory, and populate it with: \`DATABASE_URL=\\"<replace-me-with-your-connection-string>\\"\`. Prisma will automatically pick up the environment variable used in the schema and use its value to connect to your database.
4. Now you can run \`npm run init\` to set up your local database. This will create tables corresponding to models in your Prisma Schema and populate them with fake data for you to play around with.
   - [Read more about the Prisma Schema](https://www.prisma.io/docs/concepts/components/prisma-schema)
   - [Read more about database seeding](https://www.prisma.io/docs/guides/database/seed-database)

To learn more about Prisma, we recommend reading through our [Getting Started guide](https://www.prisma.io/docs/getting-started)",
    "path": "README.md",
  },
  "package.json": Object {
    "content": "{
  \\"name\\": \\"saas\\",
  \\"license\\": \\"UNLICENSED\\",
  \\"devDependencies\\": {
    \\"@types/faker\\": \\"5.5.6\\",
    \\"@types/node\\": \\"15.12.5\\",
    \\"faker\\": \\"5.5.3\\",
    \\"prisma\\": \\"2.25.0\\",
    \\"ts-node\\": \\"10.0.0\\",
    \\"typescript\\": \\"4.3.3\\"
  },
  \\"scripts\\": {
    \\"init\\": \\"prisma db push && prisma db seed --preview-feature\\",
    \\"dev\\": \\"ts-node ./script.ts\\"
  },
  \\"dependencies\\": {
    \\"@prisma/client\\": \\"2.25.0\\"
  },
  \\"engines\\": {
    \\"node\\": \\">=12.2.0\\"
  }
}",
    "path": "package.json",
  },
  "prisma/schema.prisma": Object {
    "content": "// Schema for an identity service for a SaaS
// This service tracks existing users & their accounts, as well as invites for users who haven't joined yet

datasource db {
  provider = \\"postgresql\\"
  url      = env(\\"DATABASE_URL\\")
}

generator client {
  provider = \\"prisma-client-js\\"
}

model User {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  name      String?
  email     String
  account   Account? @relation(fields: [accountId], references: [id])
  accountId String?
}

model Account {
  id                   String   @id @default(uuid())
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt
  invites              Invite[]
  users                User[]
  stripeCustomerId     String
  stripeSubscriptionId String
  referrer             String?
  isActive             Boolean

}

model Invite {
  id        String   @id @default(uuid())
  dateSent  DateTime @default(now())
  email     String
  account   Account? @relation(fields: [accountId], references: [id])
  accountId String?
  isValid   Boolean  @default(true)
}",
    "path": "prisma/schema.prisma",
  },
  "prisma/seed.ts": Object {
    "content": "import { PrismaClient } from '@prisma/client'
import * as faker from 'faker'

const NUMBER_OF_USERS = 4
const NUMBER_OF_INVITES = 4

const data = Array.from({ length: NUMBER_OF_USERS }).map(() => ({
  email: faker.internet.email(),
  name: faker.name.firstName(),
  account: {
    stripeCustomerId: faker.datatype.uuid(),
    stripeSubscriptionId: faker.datatype.uuid(),
    isActive: true,
  },
  invites: Array.from({
    length: faker.datatype.number({ min: 0, max: NUMBER_OF_INVITES }),
  }).map(() => ({
    email: faker.internet.email(),
    dateSent: faker.date.future(),
  })),
}))

export async function seed() {
  const prisma = new PrismaClient()

  let error
  try {
    for (let entry of data) {
      await prisma.user.create({
        data: {
          name: entry.name,
          email: entry.email,
          account: {
            create: {
              stripeCustomerId: entry.account.stripeCustomerId,
              stripeSubscriptionId: entry.account.stripeSubscriptionId,
              isActive: true,
              invites: {
                create: entry.invites,
              },
            },
          },
        },
      })
    }
  } catch (e) {
    await prisma.$disconnect()
    throw e
  } finally {
    await prisma.$disconnect()
  }
}",
    "path": "prisma/seed.ts",
  },
  "script.ts": Object {
    "content": "import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient()

const main = async () => {
  const accounts = await prisma.account.findMany({
    where: {
      isActive: true,
    },
  })

  console.log('Premium accounts: ', accounts)
}

main()
  .catch((e) => console.error('Error in Prisma Client query: ', e))
  .finally(async () => await prisma.$disconnect())",
    "path": "script.ts",
  },
  "tsconfig.json": Object {
    "content": "{
  \\"compilerOptions\\": {
    \\"sourceMap\\": true,
    \\"outDir\\": \\"dist\\",
    \\"strict\\": true,
    \\"lib\\": [\\"esnext\\", \\"dom\\"],
    \\"esModuleInterop\\": true
  }
}",
    "path": "tsconfig.json",
  },
}
`;

exports[`Template classes have static data files urlShortener 1`] = `
Object {
  "README.md": Object {
    "content": "# URL Shortener

![Database diagram](https://raw.githubusercontent.com/prisma/prisma-schema-examples/main/urlShortener/diagram.png)

(Generated via https://github.com/notiz-dev/prisma-dbml-generator + https://dbdiagram.io)

### Setting this project up locally

Once you clone your repo, you'll want to set up this repo for local development. In order to start using Prisma locally, you need to make Prisma aware of your database. The most portable way to do this is to use environment variables via a \`.env\` file.

1. You'll see that your Prisma Schema file (at \`prisma/schema.prisma\`) is already configured to use an environment variable called \`DATABASE_URL\`. [Read more about environment variables in Prisma](https://www.prisma.io/docs/concepts/more/environment-variables)
2. You'll need a database to connect to. You may use the same one you used while setting this project up on the Prisma Data Platform, but we recommend setting up a local database and use that during development. If you're new to databases, we recommend [reading up](https://www.prisma.io/dataguide/) on them. This guide also has instructions on how to set up a local database.
3. Once you have a locally accessible database connection string, create a new file called \`.env\` in the \`prisma\` directory, and populate it with: \`DATABASE_URL=\\"<replace-me-with-your-connection-string>\\"\`. Prisma will automatically pick up the environment variable used in the schema and use its value to connect to your database.
4. Now you can run \`npm run init\` to set up your local database. This will create tables corresponding to models in your Prisma Schema and populate them with fake data for you to play around with.
   - [Read more about the Prisma Schema](https://www.prisma.io/docs/concepts/components/prisma-schema)
   - [Read more about database seeding](https://www.prisma.io/docs/guides/database/seed-database)

To learn more about Prisma, we recommend reading through our [Getting Started guide](https://www.prisma.io/docs/getting-started)",
    "path": "README.md",
  },
  "package.json": Object {
    "content": "{
  \\"name\\": \\"url-shortener\\",
  \\"license\\": \\"UNLICENSED\\",
  \\"devDependencies\\": {
    \\"@types/faker\\": \\"5.5.6\\",
    \\"@types/node\\": \\"15.12.5\\",
    \\"faker\\": \\"5.5.3\\",
    \\"prisma\\": \\"2.25.0\\",
    \\"ts-node\\": \\"10.0.0\\",
    \\"typescript\\": \\"4.3.3\\"
  },
  \\"scripts\\": {
    \\"init\\": \\"prisma db push && prisma db seed --preview-feature\\",
    \\"dev\\": \\"ts-node ./script.ts\\"
  },
  \\"dependencies\\": {
    \\"@prisma/client\\": \\"2.25.0\\"
  },
  \\"engines\\": {
    \\"node\\": \\">=12.2.0\\"
  }
}",
    "path": "package.json",
  },
  "prisma/schema.prisma": Object {
    "content": "// Schema for a simple URL shortener
// This schema tracks short links by associating them to a user

datasource db {
  provider = \\"postgresql\\"
  url      = env(\\"DATABASE_URL\\")
}

generator client {
  provider = \\"prisma-client-js\\"
}

model Link {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  url       String
  shortUrl  String
  User      User?    @relation(fields: [userId], references: [id])
  userId    String?
}

model User {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  name      String?
  email     String
  links     Link[]
}",
    "path": "prisma/schema.prisma",
  },
  "prisma/seed.ts": Object {
    "content": "import { PrismaClient } from '@prisma/client'
import * as faker from 'faker'

const NUMBER_OF_USERS = 4
const MAX_NUMBER_OF_LINKS = 5

const data = Array.from({ length: NUMBER_OF_USERS }).map(() => ({
  email: faker.internet.email(),
  name: faker.name.firstName(),
  links: Array.from({
    length: faker.datatype.number({
      min: 0,
      max: MAX_NUMBER_OF_LINKS,
    }),
  }).map(() => ({
    url: faker.internet.url(),
    shortUrl: faker.internet.domainWord(),
  })),
}))

export async function seed() {
  const prisma = new PrismaClient()

  try {
    for (let entry of data) {
      await prisma.user.create({
        data: {
          name: entry.name,
          email: entry.email,
          links: {
            create: entry.links,
          },
        },
      })
    }
  } catch (e) {
    await prisma.$disconnect()
    throw e
  } finally {
    await prisma.$disconnect()
  }
}",
    "path": "prisma/seed.ts",
  },
  "script.ts": Object {
    "content": "import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient()

const main = async () => {
  const users = await prisma.user.findMany({
    where: {
      name: {
        startsWith: 'A',
      },
    },
  })

  console.log('Top users (alphabetical): ', users)
}

main()
  .catch((e) => console.error('Error in Prisma Client query: ', e))
  .finally(async () => await prisma.$disconnect())",
    "path": "script.ts",
  },
  "tsconfig.json": Object {
    "content": "{
  \\"compilerOptions\\": {
    \\"sourceMap\\": true,
    \\"outDir\\": \\"dist\\",
    \\"strict\\": true,
    \\"lib\\": [\\"esnext\\", \\"dom\\"],
    \\"esModuleInterop\\": true
  }
}",
    "path": "tsconfig.json",
  },
}
`;

exports[`Template classes have static data metadata empty 1`] = `
Object {
  "displayName": "Empty",
  "githubUrl": "https://github.com/prisma/prisma-schema-examples/tree/main/empty",
  "name": "empty",
}
`;

exports[`Template classes have static data metadata musicStreamingService 1`] = `
Object {
  "displayName": "Music Streaming Service",
  "githubUrl": "https://github.com/prisma/prisma-schema-examples/tree/main/musicStreamingService",
  "name": "musicStreamingService",
}
`;

exports[`Template classes have static data metadata rentalsPlatform 1`] = `
Object {
  "displayName": "Rentals Platform",
  "githubUrl": "https://github.com/prisma/prisma-schema-examples/tree/main/rentalsPlatform",
  "name": "rentalsPlatform",
}
`;

exports[`Template classes have static data metadata saas 1`] = `
Object {
  "displayName": "Saas",
  "githubUrl": "https://github.com/prisma/prisma-schema-examples/tree/main/saas",
  "name": "saas",
}
`;

exports[`Template classes have static data metadata urlShortener 1`] = `
Object {
  "displayName": "Url Shortener",
  "githubUrl": "https://github.com/prisma/prisma-schema-examples/tree/main/urlShortener",
  "name": "urlShortener",
}
`;

exports[`templates can be instantiated with custom datasourceProvider empty 1`] = `
Empty {
  "artifacts": Object {
    "prisma/seed.js": Object {
      "content": "\\"use strict\\";

Object.defineProperty(exports, \\"__esModule\\", {
  value: true
});
exports.seed = seed;

var _studioPcw = require(\\"@prisma/studio-pcw\\");

const schema = \`PRISMA TEMPLATE: empty\`;
const schemaPath = \\"/tmp/schema.prisma\\";

async function seed() {
  const pcw = new _studioPcw.PCW(schema, schemaPath, {
    PRISMA_CLOUD_PROJECT_DATASOURCE_URL: process.env.PRISMA_CLOUD_PROJECT_DATASOURCE_URL
  }, {
    forcePrismaLibrary: true,
    resolve: {
      \\".prisma/client\\": require.resolve(\\".prisma/client\\")
    }
  });
  const {
    prisma: prisma
  } = await pcw.getPrismaClient();
}

(async () => await seed())()",
      "path": "prisma/seed.js",
    },
  },
  "files": Object {
    "README.md": Object {
      "content": "# Empty Prisma Project

An empty Prisma Schema with no models, perfect as a starting point for your own schema.",
      "path": "README.md",
    },
    "package.json": Object {
      "content": "{
  \\"name\\": \\"empty\\",
  \\"license\\": \\"UNLICENSED\\",
  \\"devDependencies\\": {
    \\"prisma\\": \\"2.25.0\\"
  },
  \\"dependencies\\": {
    \\"@prisma/client\\": \\"2.25.0\\"
  },
  \\"engines\\": {
    \\"node\\": \\">=10.0.0\\"
  }
}",
      "path": "package.json",
    },
    "prisma/schema.prisma": Object {
      "content": "// An empty Prisma Schema with no models, perfect as a starting point for your own schema.

datasource db {
  provider = \\"mysql\\"
  url      = env(\\"DATABASE_URL\\")
}

generator client {
  provider = \\"prisma-client-js\\"
}",
      "path": "prisma/schema.prisma",
    },
    "prisma/seed.ts": Object {
      "content": "import { PrismaClient } from \\"@prisma/client\\";

export async function seed() {
  const prisma = new PrismaClient();
}",
      "path": "prisma/seed.ts",
    },
  },
  "metadata": Object {
    "displayName": "Empty",
    "githubUrl": "https://github.com/prisma/prisma-schema-examples/tree/main/empty",
    "name": "empty",
  },
}
`;

exports[`templates can be instantiated with custom datasourceProvider musicStreamingService 1`] = `
MusicStreamingService {
  "artifacts": Object {
    "prisma/seed.js": Object {
      "content": "\\"use strict\\";

Object.defineProperty(exports, \\"__esModule\\", {
  value: true
});
exports.seed = seed;

var _studioPcw = require(\\"@prisma/studio-pcw\\");

var faker = _interopRequireWildcard(require(\\"faker\\"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \\"function\\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \\"object\\" && typeof obj !== \\"function\\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \\"default\\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const MAX_NUMBER_OF_SONGS_PER_ARTIST = 5;
const NUMBER_OF_ARTISTS = 5;
const NUMBER_OF_USERS = 10;
const userIds = Array.from({
  length: NUMBER_OF_USERS
}).map(() => faker.datatype.uuid());
const schema = \`PRISMA TEMPLATE: musicStreamingService\`;
const schemaPath = \\"/tmp/schema.prisma\\";

async function seed() {
  const pcw = new _studioPcw.PCW(schema, schemaPath, {
    PRISMA_CLOUD_PROJECT_DATASOURCE_URL: process.env.PRISMA_CLOUD_PROJECT_DATASOURCE_URL
  }, {
    forcePrismaLibrary: true,
    resolve: {
      \\".prisma/client\\": require.resolve(\\".prisma/client\\")
    }
  });
  const {
    prisma: prisma
  } = await pcw.getPrismaClient();

  try {
    // Create artists
    await prisma.artist.createMany({
      data: Array.from({
        length: NUMBER_OF_ARTISTS
      }).map(() => ({
        name: faker.name.firstName()
      }))
    });
    const artists = await prisma.artist.findMany(); // Create songs for each artist

    for (const artist of artists) {
      await prisma.album.create({
        data: {
          cover: faker.image.imageUrl(),
          name: faker.random.words(2),
          artists: {
            connect: {
              id: artist.id
            }
          },
          songs: {
            create: Array.from({
              length: faker.datatype.number({
                min: 2,
                max: MAX_NUMBER_OF_SONGS_PER_ARTIST
              })
            }).map(() => ({
              artistId: artist.id,
              fileUrl: faker.internet.url(),
              length: faker.datatype.float(),
              name: faker.name.firstName()
            }))
          }
        }
      });
    } // Create songs


    const songs = await prisma.song.findMany();

    for (const userId of userIds) {
      // Create users
      await prisma.user.create({
        data: {
          id: userId,
          email: faker.internet.email(),
          name: faker.name.firstName(),
          interactions: {
            create: Array.from({
              length: faker.datatype.number({
                min: 3,
                max: songs.length
              })
            }).map(() => ({
              playCount: faker.datatype.number({
                min: 1,
                max: 1000
              }),
              songId: songs[faker.datatype.number({
                min: 0,
                max: songs.length - 1
              })].id,
              // random boolean
              isLiked: Math.random() < 0.5
            }))
          }
        }
      }); // Create Playlists

      await prisma.playlist.create({
        data: {
          name: faker.random.words(2),
          user: {
            connect: {
              id: userId
            }
          },
          // each playlist will have a random list of songs
          songs: {
            connect: songs.slice(0, faker.datatype.number({
              min: 1,
              max: songs.length - 1
            })).map(({
              id
            }) => ({
              id
            }))
          }
        }
      });
    }
  } catch (e) {
    await prisma.$disconnect();
    throw e;
  } finally {
    await prisma.$disconnect();
  }
}

(async () => await seed())()",
      "path": "prisma/seed.js",
    },
  },
  "files": Object {
    "README.md": Object {
      "content": "# Music Streaming Service

![Database diagram](https://raw.githubusercontent.com/prisma/prisma-schema-examples/main/musicStreamingService/diagram.png)

(Generated via https://github.com/notiz-dev/prisma-dbml-generator + https://dbdiagram.io)

### Setting this project up locally

Once you clone your repo, you'll want to set up this repo for local development. In order to start using Prisma locally, you need to make Prisma aware of your database. The most portable way to do this is to use environment variables via a \`.env\` file.

1. You'll see that your Prisma Schema file (at \`prisma/schema.prisma\`) is already configured to use an environment variable called \`DATABASE_URL\`. [Read more about environment variables in Prisma](https://www.prisma.io/docs/concepts/more/environment-variables)
2. You'll need a database to connect to. You may use the same one you used while setting this project up on the Prisma Data Platform, but we recommend setting up a local database and use that during development. If you're new to databases, we recommend [reading up](https://www.prisma.io/dataguide/) on them. This guide also has instructions on how to set up a local database.
3. Once you have a locally accessible database connection string, create a new file called \`.env\` in the \`prisma\` directory, and populate it with: \`DATABASE_URL=\\"<replace-me-with-your-connection-string>\\"\`. Prisma will automatically pick up the environment variable used in the schema and use its value to connect to your database.
4. Now you can run \`npm run init\` to set up your local database. This will create tables corresponding to models in your Prisma Schema and populate them with fake data for you to play around with.
   - [Read more about the Prisma Schema](https://www.prisma.io/docs/concepts/components/prisma-schema)
   - [Read more about database seeding](https://www.prisma.io/docs/guides/database/seed-database)

To learn more about Prisma, we recommend reading through our [Getting Started guide](https://www.prisma.io/docs/getting-started)",
      "path": "README.md",
    },
    "package.json": Object {
      "content": "{
  \\"name\\": \\"music-streaming-service\\",
  \\"license\\": \\"UNLICENSED\\",
  \\"devDependencies\\": {
    \\"@types/faker\\": \\"5.5.6\\",
    \\"@types/node\\": \\"15.12.5\\",
    \\"faker\\": \\"5.5.3\\",
    \\"prisma\\": \\"2.25.0\\",
    \\"ts-node\\": \\"10.0.0\\",
    \\"typescript\\": \\"4.3.3\\"
  },
  \\"scripts\\": {
    \\"init\\": \\"prisma db push && prisma db seed --preview-feature\\",
    \\"dev\\": \\"ts-node ./script.ts\\"
  },
  \\"dependencies\\": {
    \\"@prisma/client\\": \\"2.25.0\\"
  },
  \\"engines\\": {
    \\"node\\": \\">=12.2.0\\"
  }
}",
      "path": "package.json",
    },
    "prisma/schema.prisma": Object {
      "content": "// Schema for a fictional music streaming service
// This service contains songs, albums, artists & playlists, and tracks user interactions with each of them

datasource db {
  provider = \\"mysql\\"
  url      = env(\\"DATABASE_URL\\")
}

generator client {
  provider = \\"prisma-client-js\\"
}

model User {
  id           String        @id @default(uuid())
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt
  name         String
  email        String        @unique
  interactions Interaction[]
  playlists    Playlist[]
}

model Interaction {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  songId    String?
  userId    String?
  isLiked   Boolean  @default(false)
  playCount Int
  song      Song?    @relation(fields: [songId], references: [id])
  user      User?    @relation(fields: [userId], references: [id])
}

model Song {
  id           String        @id @default(uuid())
  interactions Interaction[]
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt
  name         String
  album        Album?        @relation(fields: [albumId], references: [id])
  albumId      String?
  artist       Artist        @relation(fields: [artistId], references: [id])
  artistId     String
  length       Float
  track        Int?
  lyrics       String?
  playlist     Playlist[]
  fileUrl      String
}

model Artist {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  name      String
  albums    Album[]
  songs     Song[]
}

model Album {
  id        String   @id @default(uuid())
  songs     Song[]
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  artists   Artist[]
  name      String
  cover     String
}

model Playlist {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  user      User?    @relation(fields: [userId], references: [id])
  userId    String?
  songs     Song[]
  name      String
}",
      "path": "prisma/schema.prisma",
    },
    "prisma/seed.ts": Object {
      "content": "import { PrismaClient } from '@prisma/client'
import * as faker from 'faker'

const MAX_NUMBER_OF_SONGS_PER_ARTIST = 5
const NUMBER_OF_ARTISTS = 5
const NUMBER_OF_USERS = 10

const userIds = Array.from({
  length: NUMBER_OF_USERS,
}).map(() => faker.datatype.uuid())

export async function seed() {
  const prisma = new PrismaClient()

  try {
    // Create artists
    await prisma.artist.createMany({
      data: Array.from({ length: NUMBER_OF_ARTISTS }).map(() => ({
        name: faker.name.firstName(),
      })),
    })

    const artists = await prisma.artist.findMany()

    // Create songs for each artist
    for (const artist of artists) {
      await prisma.album.create({
        data: {
          cover: faker.image.imageUrl(),
          name: faker.random.words(2),
          artists: {
            connect: {
              id: artist.id,
            },
          },
          songs: {
            create: Array.from({
              length: faker.datatype.number({
                min: 2,
                max: MAX_NUMBER_OF_SONGS_PER_ARTIST,
              }),
            }).map(() => ({
              artistId: artist.id,
              fileUrl: faker.internet.url(),
              length: faker.datatype.float(),
              name: faker.name.firstName(),
            })),
          },
        },
      })
    }

    // Create songs
    const songs = await prisma.song.findMany()

    for (const userId of userIds) {
      // Create users
      await prisma.user.create({
        data: {
          id: userId,
          email: faker.internet.email(),
          name: faker.name.firstName(),
          interactions: {
            create: Array.from({
              length: faker.datatype.number({
                min: 3,
                max: songs.length,
              }),
            }).map(() => ({
              playCount: faker.datatype.number({ min: 1, max: 1000 }),
              songId:
                songs[faker.datatype.number({ min: 0, max: songs.length - 1 })]
                  .id,
              // random boolean
              isLiked: Math.random() < 0.5,
            })),
          },
        },
      })

      // Create Playlists
      await prisma.playlist.create({
        data: {
          name: faker.random.words(2),
          user: {
            connect: {
              id: userId,
            },
          },
          // each playlist will have a random list of songs
          songs: {
            connect: songs
              .slice(
                0,
                faker.datatype.number({ min: 1, max: songs.length - 1 }),
              )
              .map(({ id }) => ({ id })),
          },
        },
      })
    }
  } catch (e) {
    await prisma.$disconnect()
    throw e
  } finally {
    await prisma.$disconnect()
  }
}",
      "path": "prisma/seed.ts",
    },
    "script.ts": Object {
      "content": "import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient()

const main = async () => {
  const albums = await prisma.album.findMany({
    where: {
      name: {
        contains: ' '
      }
    }
  })

  console.log('Albums that have more than 1 word: ', albums)
}

main()
  .catch((e) => console.error('Error in Prisma Client query: ', e))
  .finally(async () => await prisma.$disconnect())",
      "path": "script.ts",
    },
    "tsconfig.json": Object {
      "content": "{
  \\"compilerOptions\\": {
    \\"sourceMap\\": true,
    \\"outDir\\": \\"dist\\",
    \\"strict\\": true,
    \\"lib\\": [\\"esnext\\", \\"dom\\"],
    \\"esModuleInterop\\": true
  }
}",
      "path": "tsconfig.json",
    },
  },
  "metadata": Object {
    "displayName": "Music Streaming Service",
    "githubUrl": "https://github.com/prisma/prisma-schema-examples/tree/main/musicStreamingService",
    "name": "musicStreamingService",
  },
}
`;

exports[`templates can be instantiated with custom datasourceProvider rentalsPlatform 1`] = `
RentalsPlatform {
  "artifacts": Object {
    "prisma/seed.js": Object {
      "content": "\\"use strict\\";

Object.defineProperty(exports, \\"__esModule\\", {
  value: true
});
exports.seed = seed;

var _studioPcw = require(\\"@prisma/studio-pcw\\");

var faker = _interopRequireWildcard(require(\\"faker\\"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \\"function\\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \\"object\\" && typeof obj !== \\"function\\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \\"default\\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const NUMBER_OF_USERS = 10;
const NUMBER_OF_ROOMS = 20;
const roomIds = Array.from({
  length: NUMBER_OF_ROOMS
}).map(() => faker.datatype.uuid());
const rooms = Array.from({
  length: NUMBER_OF_ROOMS
}).map((_, i) => ({
  id: roomIds[i],
  price: faker.datatype.number({
    min: 50,
    max: 600
  }),
  // random address - example: b-365
  address: \`\${faker.address.streetPrefix()}-\${faker.datatype.number({
    min: 300,
    max: 1
  })}\`,
  totalOccupancy: faker.datatype.number({
    min: 1,
    max: 5
  }),
  totalBedrooms: faker.datatype.number({
    min: 1,
    max: 5
  }),
  totalBathrooms: faker.datatype.number({
    min: 1,
    max: 5
  }),
  summary: faker.lorem.paragraph(),
  media: Array.from({
    length: faker.datatype.number({
      min: 1,
      max: 5
    })
  }).map(() => ({
    fileName: faker.image.imageUrl()
  }))
}));
const data = Array.from({
  length: NUMBER_OF_USERS
}).map(() => ({
  email: faker.internet.email(),
  name: faker.name.firstName(),
  reviews: Array.from({
    length: faker.datatype.number({
      max: 1,
      min: 4
    })
  }).map(() => ({
    comment: faker.lorem.paragraph(),
    rating: faker.datatype.number({
      max: 1,
      min: 5
    })
  })),
  // create random reservations per user
  reservations: Array.from({
    length: faker.datatype.number({
      min: 1,
      max: 4
    })
  }).map(() => {
    const startDate = faker.date.past();
    const endDate = faker.date.future();
    const price = faker.datatype.number({
      min: 50,
      max: 600
    });
    return {
      startDate,
      endDate,
      price,
      total: Math.ceil(Math.abs(+endDate - +startDate) / (1000 * 60 * 60 * 24)) * price,
      // difference between dates * price
      room: {
        connect: {
          id: roomIds[faker.datatype.number({
            min: 0,
            max: NUMBER_OF_ROOMS - 1
          })]
        }
      }
    };
  })
}));
const schema = \`PRISMA TEMPLATE: rentalsPlatform\`;
const schemaPath = \\"/tmp/schema.prisma\\";

async function seed() {
  const pcw = new _studioPcw.PCW(schema, schemaPath, {
    PRISMA_CLOUD_PROJECT_DATASOURCE_URL: process.env.PRISMA_CLOUD_PROJECT_DATASOURCE_URL
  }, {
    forcePrismaLibrary: true,
    resolve: {
      \\".prisma/client\\": require.resolve(\\".prisma/client\\")
    }
  });
  const {
    prisma: prisma
  } = await pcw.getPrismaClient();

  try {
    rooms.forEach(async room => await prisma.room.create({
      data: {
        id: room.id,
        address: room.address,
        price: room.price,
        summary: room.summary,
        media: {
          create: room.media
        }
      }
    }));

    for (let entry of data) {
      await prisma.user.create({
        data: {
          email: entry.email,
          name: entry.name,
          reservations: {
            create: entry.reservations
          },
          reviews: {
            create: entry.reviews
          }
        }
      });
    }
  } catch (e) {
    await prisma.$disconnect();
    throw e;
  } finally {
    await prisma.$disconnect();
  }
}

(async () => await seed())()",
      "path": "prisma/seed.js",
    },
  },
  "files": Object {
    "README.md": Object {
      "content": "# Rentals Platform

![Database Diagram](https://github.com/prisma/prisma-schema-examples/blob/cloud/rentalsPlatform/diagram.png?raw=true)

(Generated via https://github.com/notiz-dev/prisma-dbml-generator + https://dbdiagram.io)

### Setting this project up locally

Once you clone your repo, you'll want to set up this repo for local development. In order to start using Prisma locally, you need to make Prisma aware of your database. The most portable way to do this is to use environment variables via a \`.env\` file.

1. You'll see that your Prisma Schema file (at \`prisma/schema.prisma\`) is already configured to use an environment variable called \`DATABASE_URL\`. [Read more about environment variables in Prisma](https://www.prisma.io/docs/concepts/more/environment-variables)
2. You'll need a database to connect to. You may use the same one you used while setting this project up on the Prisma Data Platform, but we recommend setting up a local database and use that during development. If you're new to databases, we recommend [reading up](https://www.prisma.io/dataguide/) on them. This guide also has instructions on how to set up a local database.
3. Once you have a locally accessible database connection string, create a new file called \`.env\` in the \`prisma\` directory, and populate it with: \`DATABASE_URL=\\"<replace-me-with-your-connection-string>\\"\`. Prisma will automatically pick up the environment variable used in the schema and use its value to connect to your database.
4. Now you can run \`npm run init\` to set up your local database. This will create tables corresponding to models in your Prisma Schema and populate them with fake data for you to play around with.
   - [Read more about the Prisma Schema](https://www.prisma.io/docs/concepts/components/prisma-schema)
   - [Read more about database seeding](https://www.prisma.io/docs/guides/database/seed-database)

To learn more about Prisma, we recommend reading through our [Getting Started guide](https://www.prisma.io/docs/getting-started",
      "path": "README.md",
    },
    "package.json": Object {
      "content": "{
  \\"name\\": \\"rentals-platform\\",
  \\"license\\": \\"UNLICENSED\\",
  \\"devDependencies\\": {
    \\"@types/faker\\": \\"5.5.6\\",
    \\"@types/node\\": \\"15.12.5\\",
    \\"faker\\": \\"5.5.3\\",
    \\"prisma\\": \\"2.25.0\\",
    \\"ts-node\\": \\"10.0.0\\",
    \\"typescript\\": \\"4.3.3\\"
  },
  \\"scripts\\": {
    \\"init\\": \\"prisma db push && prisma db seed --preview-feature\\",
    \\"dev\\": \\"ts-node ./script.ts\\"
  },
  \\"dependencies\\": {
    \\"@prisma/client\\": \\"2.25.0\\"
  },
  \\"engines\\": {
    \\"node\\": \\">=12.2.0\\"
  }
}",
      "path": "package.json",
    },
    "prisma/schema.prisma": Object {
      "content": "// Schema for a fictional hotel
// This hotel tracks rooms, user reservations & reviews

datasource db {
  provider = \\"mysql\\"
  url      = env(\\"DATABASE_URL\\")
}

generator client {
  provider = \\"prisma-client-js\\"
}

model User {
  id           String        @id @default(uuid())
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt
  email        String        @unique
  name         String
  reservations Reservation[]
  reviews      Review[]
}

model Reservation {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  userId    String?
  user      User?    @relation(fields: [userId], references: [id])
  startDate DateTime
  endDate   DateTime
  price     Int
  total     Int
  room      Room?    @relation(fields: [roomId], references: [id])
  roomId    String?
}

model Room {
  id                 String        @id @default(uuid())
  createdAt          DateTime      @default(now())
  updatedAt          DateTime      @updatedAt
  reservations       Reservation[]
  totalOccupancy     Int           @default(5)
  totalBedrooms      Int           @default(5)
  totalBathrooms     Int           @default(5)
  summary            String?
  address            String
  isSmoking          Boolean       @default(false)
  hasTV              Boolean       @default(true)
  hasAirConditioning Boolean       @default(true)
  hasHeating         Boolean       @default(true)
  hasWIFI            Boolean       @default(true)
  price              Int
  media              Media[]

}

model Review {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  rating    Int
  comment   String
  user      User     @relation(fields: [userId], references: [id])
  userId    String
}

model Media {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  room      Room?    @relation(fields: [roomId], references: [id])
  roomId    String?
  fileName  String
}",
      "path": "prisma/schema.prisma",
    },
    "prisma/seed.ts": Object {
      "content": "import { PrismaClient } from '@prisma/client'
import * as faker from 'faker'

const NUMBER_OF_USERS = 10
const NUMBER_OF_ROOMS = 20

const roomIds = Array.from({
  length: NUMBER_OF_ROOMS,
}).map(() => faker.datatype.uuid())

const rooms = Array.from({
  length: NUMBER_OF_ROOMS,
}).map((_, i) => ({
  id: roomIds[i],
  price: faker.datatype.number({
    min: 50,
    max: 600,
  }),
  // random address - example: b-365
  address: \`\${faker.address.streetPrefix()}-\${faker.datatype.number({
    min: 300,
    max: 1,
  })}\`,
  totalOccupancy: faker.datatype.number({ min: 1, max: 5 }),
  totalBedrooms: faker.datatype.number({ min: 1, max: 5 }),
  totalBathrooms: faker.datatype.number({ min: 1, max: 5 }),
  summary: faker.lorem.paragraph(),
  media: Array.from({
    length: faker.datatype.number({ min: 1, max: 5 }),
  }).map(() => ({
    fileName: faker.image.imageUrl(),
  })),
}))

const data = Array.from({ length: NUMBER_OF_USERS }).map(() => ({
  email: faker.internet.email(),
  name: faker.name.firstName(),
  reviews: Array.from({
    length: faker.datatype.number({
      max: 1,
      min: 4,
    }),
  }).map(() => ({
    comment: faker.lorem.paragraph(),
    rating: faker.datatype.number({
      max: 1,
      min: 5,
    }),
  })),
  // create random reservations per user
  reservations: Array.from({
    length: faker.datatype.number({
      min: 1,
      max: 4,
    }),
  }).map(() => {
    const startDate = faker.date.past()
    const endDate = faker.date.future()
    const price = faker.datatype.number({
      min: 50,
      max: 600,
    })
    return {
      startDate,
      endDate,
      price,
      total:
        Math.ceil(Math.abs(+endDate - +startDate) / (1000 * 60 * 60 * 24)) *
        price, // difference between dates * price
      room: {
        connect: {
          id: roomIds[
            faker.datatype.number({
              min: 0,
              max: NUMBER_OF_ROOMS - 1,
            })
          ],
        },
      },
    }
  }),
}))

export async function seed() {
  const prisma = new PrismaClient()

  try {
    rooms.forEach(
      async (room) =>
        await prisma.room.create({
          data: {
            id: room.id,
            address: room.address,
            price: room.price,
            summary: room.summary,
            media: {
              create: room.media,
            },
          },
        }),
    )

    for (let entry of data) {
      await prisma.user.create({
        data: {
          email: entry.email,
          name: entry.name,
          reservations: {
            create: entry.reservations,
          },
          reviews: {
            create: entry.reviews,
          },
        },
      })
    }
  } catch (e) {
    await prisma.$disconnect()
    throw e
  } finally {
    await prisma.$disconnect()
  }
}",
      "path": "prisma/seed.ts",
    },
    "script.ts": Object {
      "content": "import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient()

const main = async () => {
  const reservations = await prisma.reservation.findMany({
    where: {
      price: {
        gte: 300,
      },
    },
  })

  console.log('Expensive reservations: ', reservations)
}

main()
  .catch((e) => console.error('Error in Prisma Client query: ', e))
  .finally(async () => await prisma.$disconnect())",
      "path": "script.ts",
    },
    "tsconfig.json": Object {
      "content": "{
  \\"compilerOptions\\": {
    \\"sourceMap\\": true,
    \\"outDir\\": \\"dist\\",
    \\"strict\\": true,
    \\"lib\\": [\\"esnext\\", \\"dom\\"],
    \\"esModuleInterop\\": true
  }
}",
      "path": "tsconfig.json",
    },
  },
  "metadata": Object {
    "displayName": "Rentals Platform",
    "githubUrl": "https://github.com/prisma/prisma-schema-examples/tree/main/rentalsPlatform",
    "name": "rentalsPlatform",
  },
}
`;

exports[`templates can be instantiated with custom datasourceProvider saas 1`] = `
Saas {
  "artifacts": Object {
    "prisma/seed.js": Object {
      "content": "\\"use strict\\";

Object.defineProperty(exports, \\"__esModule\\", {
  value: true
});
exports.seed = seed;

var _studioPcw = require(\\"@prisma/studio-pcw\\");

var faker = _interopRequireWildcard(require(\\"faker\\"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \\"function\\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \\"object\\" && typeof obj !== \\"function\\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \\"default\\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const NUMBER_OF_USERS = 4;
const NUMBER_OF_INVITES = 4;
const data = Array.from({
  length: NUMBER_OF_USERS
}).map(() => ({
  email: faker.internet.email(),
  name: faker.name.firstName(),
  account: {
    stripeCustomerId: faker.datatype.uuid(),
    stripeSubscriptionId: faker.datatype.uuid(),
    isActive: true
  },
  invites: Array.from({
    length: faker.datatype.number({
      min: 0,
      max: NUMBER_OF_INVITES
    })
  }).map(() => ({
    email: faker.internet.email(),
    dateSent: faker.date.future()
  }))
}));
const schema = \`PRISMA TEMPLATE: saas\`;
const schemaPath = \\"/tmp/schema.prisma\\";

async function seed() {
  const pcw = new _studioPcw.PCW(schema, schemaPath, {
    PRISMA_CLOUD_PROJECT_DATASOURCE_URL: process.env.PRISMA_CLOUD_PROJECT_DATASOURCE_URL
  }, {
    forcePrismaLibrary: true,
    resolve: {
      \\".prisma/client\\": require.resolve(\\".prisma/client\\")
    }
  });
  const {
    prisma: prisma
  } = await pcw.getPrismaClient();
  let error;

  try {
    for (let entry of data) {
      await prisma.user.create({
        data: {
          name: entry.name,
          email: entry.email,
          account: {
            create: {
              stripeCustomerId: entry.account.stripeCustomerId,
              stripeSubscriptionId: entry.account.stripeSubscriptionId,
              isActive: true,
              invites: {
                create: entry.invites
              }
            }
          }
        }
      });
    }
  } catch (e) {
    await prisma.$disconnect();
    throw e;
  } finally {
    await prisma.$disconnect();
  }
}

(async () => await seed())()",
      "path": "prisma/seed.js",
    },
  },
  "files": Object {
    "README.md": Object {
      "content": "# SaaS

Generic Prisma schema example for a SaaS that has a referral system.

![Database diagram](https://raw.githubusercontent.com/prisma/prisma-schema-examples/main/saas/diagram.png)

(Generated via https://github.com/notiz-dev/prisma-dbml-generator + https://dbdiagram.io)

### Setting this project up locally

Once you clone your repo, you'll want to set up this repo for local development. In order to start using Prisma locally, you need to make Prisma aware of your database. The most portable way to do this is to use environment variables via a \`.env\` file.

1. You'll see that your Prisma Schema file (at \`prisma/schema.prisma\`) is already configured to use an environment variable called \`DATABASE_URL\`. [Read more about environment variables in Prisma](https://www.prisma.io/docs/concepts/more/environment-variables)
2. You'll need a database to connect to. You may use the same one you used while setting this project up on the Prisma Data Platform, but we recommend setting up a local database and use that during development. If you're new to databases, we recommend [reading up](https://www.prisma.io/dataguide/) on them. This guide also has instructions on how to set up a local database.
3. Once you have a locally accessible database connection string, create a new file called \`.env\` in the \`prisma\` directory, and populate it with: \`DATABASE_URL=\\"<replace-me-with-your-connection-string>\\"\`. Prisma will automatically pick up the environment variable used in the schema and use its value to connect to your database.
4. Now you can run \`npm run init\` to set up your local database. This will create tables corresponding to models in your Prisma Schema and populate them with fake data for you to play around with.
   - [Read more about the Prisma Schema](https://www.prisma.io/docs/concepts/components/prisma-schema)
   - [Read more about database seeding](https://www.prisma.io/docs/guides/database/seed-database)

To learn more about Prisma, we recommend reading through our [Getting Started guide](https://www.prisma.io/docs/getting-started)",
      "path": "README.md",
    },
    "package.json": Object {
      "content": "{
  \\"name\\": \\"saas\\",
  \\"license\\": \\"UNLICENSED\\",
  \\"devDependencies\\": {
    \\"@types/faker\\": \\"5.5.6\\",
    \\"@types/node\\": \\"15.12.5\\",
    \\"faker\\": \\"5.5.3\\",
    \\"prisma\\": \\"2.25.0\\",
    \\"ts-node\\": \\"10.0.0\\",
    \\"typescript\\": \\"4.3.3\\"
  },
  \\"scripts\\": {
    \\"init\\": \\"prisma db push && prisma db seed --preview-feature\\",
    \\"dev\\": \\"ts-node ./script.ts\\"
  },
  \\"dependencies\\": {
    \\"@prisma/client\\": \\"2.25.0\\"
  },
  \\"engines\\": {
    \\"node\\": \\">=12.2.0\\"
  }
}",
      "path": "package.json",
    },
    "prisma/schema.prisma": Object {
      "content": "// Schema for an identity service for a SaaS
// This service tracks existing users & their accounts, as well as invites for users who haven't joined yet

datasource db {
  provider = \\"mysql\\"
  url      = env(\\"DATABASE_URL\\")
}

generator client {
  provider = \\"prisma-client-js\\"
}

model User {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  name      String?
  email     String
  account   Account? @relation(fields: [accountId], references: [id])
  accountId String?
}

model Account {
  id                   String   @id @default(uuid())
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt
  invites              Invite[]
  users                User[]
  stripeCustomerId     String
  stripeSubscriptionId String
  referrer             String?
  isActive             Boolean

}

model Invite {
  id        String   @id @default(uuid())
  dateSent  DateTime @default(now())
  email     String
  account   Account? @relation(fields: [accountId], references: [id])
  accountId String?
  isValid   Boolean  @default(true)
}",
      "path": "prisma/schema.prisma",
    },
    "prisma/seed.ts": Object {
      "content": "import { PrismaClient } from '@prisma/client'
import * as faker from 'faker'

const NUMBER_OF_USERS = 4
const NUMBER_OF_INVITES = 4

const data = Array.from({ length: NUMBER_OF_USERS }).map(() => ({
  email: faker.internet.email(),
  name: faker.name.firstName(),
  account: {
    stripeCustomerId: faker.datatype.uuid(),
    stripeSubscriptionId: faker.datatype.uuid(),
    isActive: true,
  },
  invites: Array.from({
    length: faker.datatype.number({ min: 0, max: NUMBER_OF_INVITES }),
  }).map(() => ({
    email: faker.internet.email(),
    dateSent: faker.date.future(),
  })),
}))

export async function seed() {
  const prisma = new PrismaClient()

  let error
  try {
    for (let entry of data) {
      await prisma.user.create({
        data: {
          name: entry.name,
          email: entry.email,
          account: {
            create: {
              stripeCustomerId: entry.account.stripeCustomerId,
              stripeSubscriptionId: entry.account.stripeSubscriptionId,
              isActive: true,
              invites: {
                create: entry.invites,
              },
            },
          },
        },
      })
    }
  } catch (e) {
    await prisma.$disconnect()
    throw e
  } finally {
    await prisma.$disconnect()
  }
}",
      "path": "prisma/seed.ts",
    },
    "script.ts": Object {
      "content": "import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient()

const main = async () => {
  const accounts = await prisma.account.findMany({
    where: {
      isActive: true,
    },
  })

  console.log('Premium accounts: ', accounts)
}

main()
  .catch((e) => console.error('Error in Prisma Client query: ', e))
  .finally(async () => await prisma.$disconnect())",
      "path": "script.ts",
    },
    "tsconfig.json": Object {
      "content": "{
  \\"compilerOptions\\": {
    \\"sourceMap\\": true,
    \\"outDir\\": \\"dist\\",
    \\"strict\\": true,
    \\"lib\\": [\\"esnext\\", \\"dom\\"],
    \\"esModuleInterop\\": true
  }
}",
      "path": "tsconfig.json",
    },
  },
  "metadata": Object {
    "displayName": "Saas",
    "githubUrl": "https://github.com/prisma/prisma-schema-examples/tree/main/saas",
    "name": "saas",
  },
}
`;

exports[`templates can be instantiated with custom datasourceProvider urlShortener 1`] = `
UrlShortener {
  "artifacts": Object {
    "prisma/seed.js": Object {
      "content": "\\"use strict\\";

Object.defineProperty(exports, \\"__esModule\\", {
  value: true
});
exports.seed = seed;

var _studioPcw = require(\\"@prisma/studio-pcw\\");

var faker = _interopRequireWildcard(require(\\"faker\\"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \\"function\\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \\"object\\" && typeof obj !== \\"function\\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \\"default\\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const NUMBER_OF_USERS = 4;
const MAX_NUMBER_OF_LINKS = 5;
const data = Array.from({
  length: NUMBER_OF_USERS
}).map(() => ({
  email: faker.internet.email(),
  name: faker.name.firstName(),
  links: Array.from({
    length: faker.datatype.number({
      min: 0,
      max: MAX_NUMBER_OF_LINKS
    })
  }).map(() => ({
    url: faker.internet.url(),
    shortUrl: faker.internet.domainWord()
  }))
}));
const schema = \`PRISMA TEMPLATE: urlShortener\`;
const schemaPath = \\"/tmp/schema.prisma\\";

async function seed() {
  const pcw = new _studioPcw.PCW(schema, schemaPath, {
    PRISMA_CLOUD_PROJECT_DATASOURCE_URL: process.env.PRISMA_CLOUD_PROJECT_DATASOURCE_URL
  }, {
    forcePrismaLibrary: true,
    resolve: {
      \\".prisma/client\\": require.resolve(\\".prisma/client\\")
    }
  });
  const {
    prisma: prisma
  } = await pcw.getPrismaClient();

  try {
    for (let entry of data) {
      await prisma.user.create({
        data: {
          name: entry.name,
          email: entry.email,
          links: {
            create: entry.links
          }
        }
      });
    }
  } catch (e) {
    await prisma.$disconnect();
    throw e;
  } finally {
    await prisma.$disconnect();
  }
}

(async () => await seed())()",
      "path": "prisma/seed.js",
    },
  },
  "files": Object {
    "README.md": Object {
      "content": "# URL Shortener

![Database diagram](https://raw.githubusercontent.com/prisma/prisma-schema-examples/main/urlShortener/diagram.png)

(Generated via https://github.com/notiz-dev/prisma-dbml-generator + https://dbdiagram.io)

### Setting this project up locally

Once you clone your repo, you'll want to set up this repo for local development. In order to start using Prisma locally, you need to make Prisma aware of your database. The most portable way to do this is to use environment variables via a \`.env\` file.

1. You'll see that your Prisma Schema file (at \`prisma/schema.prisma\`) is already configured to use an environment variable called \`DATABASE_URL\`. [Read more about environment variables in Prisma](https://www.prisma.io/docs/concepts/more/environment-variables)
2. You'll need a database to connect to. You may use the same one you used while setting this project up on the Prisma Data Platform, but we recommend setting up a local database and use that during development. If you're new to databases, we recommend [reading up](https://www.prisma.io/dataguide/) on them. This guide also has instructions on how to set up a local database.
3. Once you have a locally accessible database connection string, create a new file called \`.env\` in the \`prisma\` directory, and populate it with: \`DATABASE_URL=\\"<replace-me-with-your-connection-string>\\"\`. Prisma will automatically pick up the environment variable used in the schema and use its value to connect to your database.
4. Now you can run \`npm run init\` to set up your local database. This will create tables corresponding to models in your Prisma Schema and populate them with fake data for you to play around with.
   - [Read more about the Prisma Schema](https://www.prisma.io/docs/concepts/components/prisma-schema)
   - [Read more about database seeding](https://www.prisma.io/docs/guides/database/seed-database)

To learn more about Prisma, we recommend reading through our [Getting Started guide](https://www.prisma.io/docs/getting-started)",
      "path": "README.md",
    },
    "package.json": Object {
      "content": "{
  \\"name\\": \\"url-shortener\\",
  \\"license\\": \\"UNLICENSED\\",
  \\"devDependencies\\": {
    \\"@types/faker\\": \\"5.5.6\\",
    \\"@types/node\\": \\"15.12.5\\",
    \\"faker\\": \\"5.5.3\\",
    \\"prisma\\": \\"2.25.0\\",
    \\"ts-node\\": \\"10.0.0\\",
    \\"typescript\\": \\"4.3.3\\"
  },
  \\"scripts\\": {
    \\"init\\": \\"prisma db push && prisma db seed --preview-feature\\",
    \\"dev\\": \\"ts-node ./script.ts\\"
  },
  \\"dependencies\\": {
    \\"@prisma/client\\": \\"2.25.0\\"
  },
  \\"engines\\": {
    \\"node\\": \\">=12.2.0\\"
  }
}",
      "path": "package.json",
    },
    "prisma/schema.prisma": Object {
      "content": "// Schema for a simple URL shortener
// This schema tracks short links by associating them to a user

datasource db {
  provider = \\"mysql\\"
  url      = env(\\"DATABASE_URL\\")
}

generator client {
  provider = \\"prisma-client-js\\"
}

model Link {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  url       String
  shortUrl  String
  User      User?    @relation(fields: [userId], references: [id])
  userId    String?
}

model User {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  name      String?
  email     String
  links     Link[]
}",
      "path": "prisma/schema.prisma",
    },
    "prisma/seed.ts": Object {
      "content": "import { PrismaClient } from '@prisma/client'
import * as faker from 'faker'

const NUMBER_OF_USERS = 4
const MAX_NUMBER_OF_LINKS = 5

const data = Array.from({ length: NUMBER_OF_USERS }).map(() => ({
  email: faker.internet.email(),
  name: faker.name.firstName(),
  links: Array.from({
    length: faker.datatype.number({
      min: 0,
      max: MAX_NUMBER_OF_LINKS,
    }),
  }).map(() => ({
    url: faker.internet.url(),
    shortUrl: faker.internet.domainWord(),
  })),
}))

export async function seed() {
  const prisma = new PrismaClient()

  try {
    for (let entry of data) {
      await prisma.user.create({
        data: {
          name: entry.name,
          email: entry.email,
          links: {
            create: entry.links,
          },
        },
      })
    }
  } catch (e) {
    await prisma.$disconnect()
    throw e
  } finally {
    await prisma.$disconnect()
  }
}",
      "path": "prisma/seed.ts",
    },
    "script.ts": Object {
      "content": "import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient()

const main = async () => {
  const users = await prisma.user.findMany({
    where: {
      name: {
        startsWith: 'A',
      },
    },
  })

  console.log('Top users (alphabetical): ', users)
}

main()
  .catch((e) => console.error('Error in Prisma Client query: ', e))
  .finally(async () => await prisma.$disconnect())",
      "path": "script.ts",
    },
    "tsconfig.json": Object {
      "content": "{
  \\"compilerOptions\\": {
    \\"sourceMap\\": true,
    \\"outDir\\": \\"dist\\",
    \\"strict\\": true,
    \\"lib\\": [\\"esnext\\", \\"dom\\"],
    \\"esModuleInterop\\": true
  }
}",
      "path": "tsconfig.json",
    },
  },
  "metadata": Object {
    "displayName": "Url Shortener",
    "githubUrl": "https://github.com/prisma/prisma-schema-examples/tree/main/urlShortener",
    "name": "urlShortener",
  },
}
`;
