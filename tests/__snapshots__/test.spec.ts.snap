// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Template classes have static data artifcats empty 1`] = `
Object {
  "prisma/seed.js": Object {
    "content": "\\"use strict\\";

Object.defineProperty(exports, \\"__esModule\\", {
  value: true
});
exports.seed = seed;

var _studioPcw = require(\\"@prisma/studio-pcw\\");

const schema = \`PRISMA TEMPLATE: empty\`;
const schemaPath = \\"/tmp/schema.prisma\\";

async function seed() {
  const pcw = new _studioPcw.PCW(schema, schemaPath, {
    PRISMA_CLOUD_PROJECT_DATASOURCE_URL: process.env.PRISMA_CLOUD_PROJECT_DATASOURCE_URL
  }, {
    forcePrismaLibrary: true,
    resolve: {
      \\".prisma/client\\": require.resolve(\\".prisma/client\\")
    }
  });
  const {
    prisma: prisma
  } = await pcw.getPrismaClient();
}

(async () => await seed())()",
    "path": "prisma/seed.js",
  },
}
`;

exports[`Template classes have static data artifcats musicStreamingService 1`] = `
Object {
  "prisma/seed.js": Object {
    "content": "\\"use strict\\";

Object.defineProperty(exports, \\"__esModule\\", {
  value: true
});
exports.seed = seed;

var _studioPcw = require(\\"@prisma/studio-pcw\\");

var faker = _interopRequireWildcard(require(\\"faker\\"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \\"function\\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \\"object\\" && typeof obj !== \\"function\\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \\"default\\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const MAX_NUMBER_OF_SONGS_PER_ARTIST = 5;
const NUMBER_OF_ARTISTS = 5;
const NUMBER_OF_USERS = 10;
const userIds = Array.from({
  length: NUMBER_OF_USERS
}).map(() => faker.datatype.uuid());
const schema = \`PRISMA TEMPLATE: musicStreamingService\`;
const schemaPath = \\"/tmp/schema.prisma\\";

async function seed() {
  const pcw = new _studioPcw.PCW(schema, schemaPath, {
    PRISMA_CLOUD_PROJECT_DATASOURCE_URL: process.env.PRISMA_CLOUD_PROJECT_DATASOURCE_URL
  }, {
    forcePrismaLibrary: true,
    resolve: {
      \\".prisma/client\\": require.resolve(\\".prisma/client\\")
    }
  });
  const {
    prisma: prisma
  } = await pcw.getPrismaClient();

  try {
    // Create artists
    await prisma.artist.createMany({
      data: Array.from({
        length: NUMBER_OF_ARTISTS
      }).map(() => ({
        name: faker.name.firstName()
      }))
    });
    const artists = await prisma.artist.findMany(); // Create songs for each artist

    for (const artist of artists) {
      await prisma.album.create({
        data: {
          cover: faker.image.imageUrl(),
          name: faker.random.words(2),
          artists: {
            connect: {
              id: artist.id
            }
          },
          songs: {
            create: Array.from({
              length: faker.datatype.number({
                min: 2,
                max: MAX_NUMBER_OF_SONGS_PER_ARTIST
              })
            }).map(() => ({
              artistId: artist.id,
              fileUrl: faker.internet.url(),
              length: faker.datatype.float(),
              name: faker.name.firstName()
            }))
          }
        }
      });
    } // Create songs


    const songs = await prisma.song.findMany();

    for (const userId of userIds) {
      // Create users
      await prisma.user.create({
        data: {
          id: userId,
          email: faker.internet.email(),
          name: faker.name.firstName(),
          interactions: {
            create: Array.from({
              length: faker.datatype.number({
                min: 3,
                max: songs.length
              })
            }).map(() => ({
              playCount: faker.datatype.number({
                min: 1,
                max: 1000
              }),
              songId: songs[faker.datatype.number({
                min: 0,
                max: songs.length - 1
              })].id,
              // random boolean
              isLiked: Math.random() < 0.5
            }))
          }
        }
      }); // Create Playlists

      await prisma.playlist.create({
        data: {
          name: faker.random.words(2),
          user: {
            connect: {
              id: userId
            }
          },
          // each playlist will have a random list of songs
          songs: {
            connect: songs.slice(0, faker.datatype.number({
              min: 1,
              max: songs.length - 1
            })).map(({
              id
            }) => ({
              id
            }))
          }
        }
      });
    }
  } catch (e) {
    await prisma.$disconnect();
    throw e;
  } finally {
    await prisma.$disconnect();
  }
}

(async () => await seed())()",
    "path": "prisma/seed.js",
  },
}
`;

exports[`Template classes have static data artifcats rentalsPlatform 1`] = `
Object {
  "prisma/seed.js": Object {
    "content": "\\"use strict\\";

Object.defineProperty(exports, \\"__esModule\\", {
  value: true
});
exports.seed = seed;

var _studioPcw = require(\\"@prisma/studio-pcw\\");

var faker = _interopRequireWildcard(require(\\"faker\\"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \\"function\\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \\"object\\" && typeof obj !== \\"function\\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \\"default\\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const NUMBER_OF_USERS = 10;
const NUMBER_OF_ROOMS = 20;
const roomIds = Array.from({
  length: NUMBER_OF_ROOMS
}).map(() => faker.datatype.uuid());
const rooms = Array.from({
  length: NUMBER_OF_ROOMS
}).map((_, i) => ({
  id: roomIds[i],
  price: faker.datatype.number({
    min: 50,
    max: 600
  }),
  // random address - example: b-365
  address: \`\${faker.address.streetPrefix()}-\${faker.datatype.number({
    min: 300,
    max: 1
  })}\`,
  totalOccupancy: faker.datatype.number({
    min: 1,
    max: 5
  }),
  totalBedrooms: faker.datatype.number({
    min: 1,
    max: 5
  }),
  totalBathrooms: faker.datatype.number({
    min: 1,
    max: 5
  }),
  summary: faker.lorem.paragraph(),
  media: Array.from({
    length: faker.datatype.number({
      min: 1,
      max: 5
    })
  }).map(() => ({
    fileName: faker.image.imageUrl()
  }))
}));
const users = Array.from({
  length: NUMBER_OF_USERS
}).map(() => ({
  email: faker.internet.email(),
  name: faker.name.firstName(),
  reviews: Array.from({
    length: faker.datatype.number({
      max: 1,
      min: 4
    })
  }).map(() => ({
    comment: faker.lorem.paragraph(),
    rating: faker.datatype.number({
      max: 1,
      min: 5
    })
  })),
  // create random reservations per user
  reservations: Array.from({
    length: faker.datatype.number({
      min: 1,
      max: 4
    })
  }).map(() => {
    const startDate = faker.date.past();
    const endDate = faker.date.future();
    const price = faker.datatype.number({
      min: 50,
      max: 600
    });
    return {
      startDate,
      endDate,
      price,
      total: Math.ceil(Math.abs(+endDate - +startDate) / (1000 * 60 * 60 * 24)) * price,
      // difference between dates * price
      room: {
        connect: {
          id: roomIds[faker.datatype.number({
            min: 0,
            max: NUMBER_OF_ROOMS - 1
          })]
        }
      }
    };
  })
}));
const schema = \`PRISMA TEMPLATE: rentalsPlatform\`;
const schemaPath = \\"/tmp/schema.prisma\\";

async function seed() {
  const pcw = new _studioPcw.PCW(schema, schemaPath, {
    PRISMA_CLOUD_PROJECT_DATASOURCE_URL: process.env.PRISMA_CLOUD_PROJECT_DATASOURCE_URL
  }, {
    forcePrismaLibrary: true,
    resolve: {
      \\".prisma/client\\": require.resolve(\\".prisma/client\\")
    }
  });
  const {
    prisma: prisma
  } = await pcw.getPrismaClient();

  try {
    for (let room of rooms) {
      await prisma.room.create({
        data: {
          id: room.id,
          address: room.address,
          price: room.price,
          summary: room.summary,
          media: {
            create: room.media
          }
        }
      });
    }

    for (let user of users) {
      await prisma.user.create({
        data: {
          email: user.email,
          name: user.name,
          reservations: {
            create: user.reservations
          },
          reviews: {
            create: user.reviews
          }
        }
      });
    }
  } catch (e) {
    await prisma.$disconnect();
    throw e;
  } finally {
    await prisma.$disconnect();
  }
}

(async () => await seed())()",
    "path": "prisma/seed.js",
  },
}
`;

exports[`Template classes have static data artifcats saas 1`] = `
Object {
  "prisma/seed.js": Object {
    "content": "\\"use strict\\";

Object.defineProperty(exports, \\"__esModule\\", {
  value: true
});
exports.seed = seed;

var _studioPcw = require(\\"@prisma/studio-pcw\\");

var faker = _interopRequireWildcard(require(\\"faker\\"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \\"function\\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \\"object\\" && typeof obj !== \\"function\\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \\"default\\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const NUMBER_OF_USERS = 4;
const NUMBER_OF_INVITES = 4;
const data = Array.from({
  length: NUMBER_OF_USERS
}).map(() => ({
  email: faker.internet.email(),
  name: faker.name.firstName(),
  account: {
    stripeCustomerId: faker.datatype.uuid(),
    stripeSubscriptionId: faker.datatype.uuid(),
    isActive: true
  },
  invites: Array.from({
    length: faker.datatype.number({
      min: 0,
      max: NUMBER_OF_INVITES
    })
  }).map(() => ({
    email: faker.internet.email(),
    dateSent: faker.date.future()
  }))
}));
const schema = \`PRISMA TEMPLATE: saas\`;
const schemaPath = \\"/tmp/schema.prisma\\";

async function seed() {
  const pcw = new _studioPcw.PCW(schema, schemaPath, {
    PRISMA_CLOUD_PROJECT_DATASOURCE_URL: process.env.PRISMA_CLOUD_PROJECT_DATASOURCE_URL
  }, {
    forcePrismaLibrary: true,
    resolve: {
      \\".prisma/client\\": require.resolve(\\".prisma/client\\")
    }
  });
  const {
    prisma: prisma
  } = await pcw.getPrismaClient();

  try {
    for (let entry of data) {
      await prisma.user.create({
        data: {
          name: entry.name,
          email: entry.email,
          account: {
            create: {
              stripeCustomerId: entry.account.stripeCustomerId,
              stripeSubscriptionId: entry.account.stripeSubscriptionId,
              isActive: true,
              invites: {
                create: entry.invites
              }
            }
          }
        }
      });
    }
  } catch (e) {
    await prisma.$disconnect();
    throw e;
  } finally {
    await prisma.$disconnect();
  }
}

(async () => await seed())()",
    "path": "prisma/seed.js",
  },
}
`;

exports[`Template classes have static data artifcats urlShortener 1`] = `
Object {
  "prisma/seed.js": Object {
    "content": "\\"use strict\\";

Object.defineProperty(exports, \\"__esModule\\", {
  value: true
});
exports.seed = seed;

var _studioPcw = require(\\"@prisma/studio-pcw\\");

var faker = _interopRequireWildcard(require(\\"faker\\"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \\"function\\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \\"object\\" && typeof obj !== \\"function\\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \\"default\\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const NUMBER_OF_USERS = 4;
const MAX_NUMBER_OF_LINKS = 5;
const data = Array.from({
  length: NUMBER_OF_USERS
}).map(() => ({
  email: faker.internet.email(),
  name: faker.name.firstName(),
  links: Array.from({
    length: faker.datatype.number({
      min: 0,
      max: MAX_NUMBER_OF_LINKS
    })
  }).map(() => ({
    url: faker.internet.url(),
    shortUrl: faker.internet.domainWord()
  }))
}));
const schema = \`PRISMA TEMPLATE: urlShortener\`;
const schemaPath = \\"/tmp/schema.prisma\\";

async function seed() {
  const pcw = new _studioPcw.PCW(schema, schemaPath, {
    PRISMA_CLOUD_PROJECT_DATASOURCE_URL: process.env.PRISMA_CLOUD_PROJECT_DATASOURCE_URL
  }, {
    forcePrismaLibrary: true,
    resolve: {
      \\".prisma/client\\": require.resolve(\\".prisma/client\\")
    }
  });
  const {
    prisma: prisma
  } = await pcw.getPrismaClient();

  try {
    for (let entry of data) {
      await prisma.user.create({
        data: {
          name: entry.name,
          email: entry.email,
          links: {
            create: entry.links
          }
        }
      });
    }
  } catch (e) {
    await prisma.$disconnect();
    throw e;
  } finally {
    await prisma.$disconnect();
  }
}

(async () => await seed())()",
    "path": "prisma/seed.js",
  },
}
`;

exports[`Template classes have static data files empty 1`] = `
Object {
  "README.md": Object {
    "content": "# Empty Prisma Project

An empty Prisma Schema with no models, perfect as a starting point for your own schema.",
    "path": "README.md",
  },
  "package.json": Object {
    "content": "{
  \\"name\\": \\"empty\\",
  \\"license\\": \\"UNLICENSED\\",
  \\"devDependencies\\": {
    \\"prisma\\": \\"2.30.3\\"
  },
  \\"dependencies\\": {
    \\"@prisma/client\\": \\"3.0.1\\"
  },
  \\"engines\\": {
    \\"node\\": \\">=10.0.0\\"
  }
}",
    "path": "package.json",
  },
  "prisma/schema.prisma": Object {
    "content": "// An empty Prisma Schema with no models, perfect as a starting point for your own schema.

datasource db {
  provider = \\"postgresql\\"
  url      = env(\\"DATABASE_URL\\")
}

generator client {
  provider = \\"prisma-client-js\\"
}",
    "path": "prisma/schema.prisma",
  },
  "prisma/seed.ts": Object {
    "content": "import { PrismaClient } from \\"@prisma/client\\";

export async function seed() {
  const prisma = new PrismaClient();
}",
    "path": "prisma/seed.ts",
  },
  "public/index.html": Object {
    "content": "<html>
  <head>
    <title>Empty Template</title>

    <link rel=\\"icon\\" type=\\"image/svg\\" href=\\"prisma.svg\\" />
    <style>
      @font-face {
        font-family: Inter;
        font-weight: 400;
        src: url('https://cdn.jsdelivr.net/npm/@fontsource/inter/files/inter-latin-400-normal.woff2')
            format('woff2'),
          url('https://cdn.jsdelivr.net/npm/@fontsource/inter/files/inter-latin-400-normal.woff')
            format('woff');
      }

      @font-face {
        font-family: Inter;
        font-weight: 900;
        src: url('https://cdn.jsdelivr.net/npm/@fontsource/inter/files/inter-latin-900-normal.woff2')
            format('woff2'),
          url('https://cdn.jsdelivr.net/npm/@fontsource/inter/files/inter-latin-900-normal.woff')
            format('woff');
      }
    </style>

    <style>
      :root {
        --prisma-blue: #1a202c;
        --white: #ffffff;
        --green: #34d399;
        --black: #000000;
        --gray: rgba(0, 0, 0, 0.75);
      }
    </style>

    <style>
      body {
        margin: 0;
        padding: 0;
        font-size: 16px;
      }
      * {
        box-sizing: border-box;
      }
      h1,
      h2,
      h3,
      h4,
      h5,
      h6,
      p {
        margin: 0;
      }

      #hero {
        background: var(--prisma-blue);
        height: 60%;
        color: var(--white);
        font-family: Inter, sans-serif;
        display: flex;
        flex-direction: column;
        align-items: center;
      }

      #prisma-logo {
        padding: 50px;
      }

      #hero-text {
        display: flex;
        flex-direction: column;
        align-items: center;
        flex: 1;
      }

      #title {
        font-size: 72px;
        font-weight: 900;
        line-height: 1;
      }

      #subtitle {
        font-size: 24px;
        font-weight: 400;
        margin: 20px;
      }
      #subtitle a {
        color: var(--white) !important;
      }
    </style>
  </head>

  <body>
    <section id=\\"hero\\">
      <header style=\\"flex: 1\\">
        <img src=\\"prisma.svg\\" alt=\\"Prisma logo\\" id=\\"prisma-logo\\" />
      </header>
      <div id=\\"hero-text\\">
        <h1 id=\\"title\\">Empty Template</h1>
        <h3 id=\\"subtitle\\">
          Generated by
          <a href=\\"https://cloud.prisma.io\\" target=\\"_blank\\"
            >Prisma Data Platform</a
          >
        </h3>
      </div>
      <div style=\\"flex: 1\\"></div>
    </section>
  </body>
</html>",
    "path": "public/index.html",
  },
  "public/prisma.svg": Object {
    "content": "<svg width=\\"32\\" height=\\"40\\" viewBox=\\"0 0 32 40\\" fill=\\"none\\" xmlns=\\"http://www.w3.org/2000/svg\\">
<path fill-rule=\\"evenodd\\" clip-rule=\\"evenodd\\" d=\\"M0.28825 24.9389C-0.101619 25.5764 -0.0955847 26.3808 0.303803 27.0124L7.5326 38.4434C8.00176 39.1853 8.90609 39.5236 9.74539 39.2712L30.606 32.9977C31.7444 32.6554 32.3172 31.3823 31.8196 30.3003L18.4094 1.13932C17.7554 -0.282788 15.7839 -0.399522 14.9675 0.935524L0.28825 24.9389ZM18.1058 7.79741C17.8205 7.13653 16.854 7.23832 16.7124 7.94418L11.5428 33.7038C11.4338 34.247 11.9419 34.7108 12.4724 34.5524L26.9042 30.2411C27.3254 30.1153 27.5424 29.6497 27.368 29.2458L18.1058 7.79741Z\\" fill=\\"white\\"/>
</svg>",
    "path": "public/prisma.svg",
  },
}
`;

exports[`Template classes have static data files musicStreamingService 1`] = `
Object {
  "README.md": Object {
    "content": "# Music Streaming Service

![Database diagram](https://raw.githubusercontent.com/prisma/prisma-schema-examples/main/musicStreamingService/diagram.png)

(Generated via https://github.com/notiz-dev/prisma-dbml-generator + https://dbdiagram.io)

### Setting this project up locally

Once you clone your repo, you'll want to set up this repo for local development. In order to start using Prisma locally, you need to make Prisma aware of your database. The most portable way to do this is to use environment variables via a \`.env\` file.

1. You'll see that your Prisma Schema file (at \`prisma/schema.prisma\`) is already configured to use an environment variable called \`DATABASE_URL\`. [Read more about environment variables in Prisma](https://www.prisma.io/docs/concepts/more/environment-variables)
2. You'll need a database to connect to. You may use the same one you used while setting this project up on the Prisma Data Platform, but we recommend setting up a local database and use that during development. If you're new to databases, we recommend [reading up](https://www.prisma.io/dataguide/) on them. This guide also has instructions on how to set up a local database.
3. Once you have a locally accessible database connection string, create a new file called \`.env\` in the \`prisma\` directory, and populate it with: \`DATABASE_URL=\\"<replace-me-with-your-connection-string>\\"\`. Prisma will automatically pick up the environment variable used in the schema and use its value to connect to your database.
4. Now you can run \`npm run init\` to set up your local database. This will create tables corresponding to models in your Prisma Schema and populate them with fake data for you to play around with.
   - [Read more about the Prisma Schema](https://www.prisma.io/docs/concepts/components/prisma-schema)
   - [Read more about database seeding](https://www.prisma.io/docs/guides/database/seed-database)

To learn more about Prisma, we recommend reading through our [Getting Started guide](https://www.prisma.io/docs/getting-started)",
    "path": "README.md",
  },
  "api/album.ts": Object {
    "content": "import { PrismaClient, Prisma } from '@prisma/client'
import { VercelRequest, VercelResponse } from '@vercel/node'

type VercelRequestQuery = {
  id?: string
}

export default async function (req: VercelRequest, res: VercelResponse) {
  try {
    const { id } = req.query as VercelRequestQuery
    const prisma = new PrismaClient()

    console.log(
      '[album] Incoming request:',
      JSON.stringify(
        {
          method: req.method,
          query: req.query,
          body: req.body,
        },
        null,
        2,
      ),
    )

    switch (req.method) {
      case 'GET':
        return res.json(
          await prisma.album.findMany({
            where: { id },
          }),
        )
      case 'POST':
        return res.json(
          await prisma.album.create({
            data: req.body as Prisma.AlbumCreateInput,
          }),
        )
      case 'PUT':
        return res.json(
          await prisma.album.update({
            where: {
              id,
            },
            data: req.body as Prisma.AlbumUpdateInput,
          }),
        )
      case 'DELETE':
        return res.json(
          await prisma.album.delete({
            where: { id },
          }),
        )
    }

    return res
      .status(400)
      .send({ message: \`Unexpected request method: \${req.method}\` })
  } catch (e: any) {
    console.error('[album] Error responding:', e)
    return res.status(500).json({ message: e?.message || e })
  }
}",
    "path": "api/album.ts",
  },
  "api/artist.ts": Object {
    "content": "import { PrismaClient, Prisma } from '@prisma/client'
import { VercelRequest, VercelResponse } from '@vercel/node'

type VercelRequestQuery = {
  id?: string
}

export default async function (req: VercelRequest, res: VercelResponse) {
  try {
    const { id } = req.query as VercelRequestQuery
    const prisma = new PrismaClient()

    console.log(
      '[artist] Incoming request:',
      JSON.stringify(
        {
          method: req.method,
          query: req.query,
          body: req.body,
        },
        null,
        2,
      ),
    )

    switch (req.method) {
      case 'GET':
        return res.json(
          await prisma.artist.findMany({
            where: { id },
          }),
        )
      case 'POST':
        return res.json(
          await prisma.artist.create({
            data: req.body as Prisma.ArtistCreateInput,
          }),
        )
      case 'PUT':
        return res.json(
          await prisma.artist.update({
            where: {
              id,
            },
            data: req.body as Prisma.ArtistUpdateInput,
          }),
        )
      case 'DELETE':
        return res.json(
          await prisma.artist.delete({
            where: { id },
          }),
        )
    }

    return res
      .status(400)
      .send({ message: \`Unexpected request method: \${req.method}\` })
  } catch (e: any) {
    console.error('[artist] Error responding:', e)
    return res.status(500).json({ message: e?.message || e })
  }
}",
    "path": "api/artist.ts",
  },
  "api/interaction.ts": Object {
    "content": "import { PrismaClient, Prisma } from '@prisma/client'
import { VercelRequest, VercelResponse } from '@vercel/node'

type VercelRequestQuery = {
  id?: string
}

export default async function (req: VercelRequest, res: VercelResponse) {
  try {
    const { id } = req.query as VercelRequestQuery
    const prisma = new PrismaClient()

    console.log(
      '[interaction] Incoming request:',
      JSON.stringify(
        {
          method: req.method,
          query: req.query,
          body: req.body,
        },
        null,
        2,
      ),
    )

    switch (req.method) {
      case 'GET':
        return res.json(
          await prisma.interaction.findMany({
            where: { id },
          }),
        )
      case 'POST':
        return res.json(
          await prisma.interaction.create({
            data: req.body as Prisma.InteractionCreateInput,
          }),
        )
      case 'PUT':
        return res.json(
          await prisma.interaction.update({
            where: {
              id,
            },
            data: req.body as Prisma.InteractionUpdateInput,
          }),
        )
      case 'DELETE':
        return res.json(
          await prisma.interaction.delete({
            where: { id },
          }),
        )
    }

    return res
      .status(400)
      .send({ message: \`Unexpected request method: \${req.method}\` })
  } catch (e: any) {
    console.error('[interaction] Error responding:', e)
    return res.status(500).json({ message: e?.message || e })
  }
}",
    "path": "api/interaction.ts",
  },
  "api/playlist.ts": Object {
    "content": "import { PrismaClient, Prisma } from '@prisma/client'
import { VercelRequest, VercelResponse } from '@vercel/node'

type VercelRequestQuery = {
  id?: string
}

export default async function (req: VercelRequest, res: VercelResponse) {
  try {
    const { id } = req.query as VercelRequestQuery
    const prisma = new PrismaClient()

    console.log(
      '[playlist] Incoming request:',
      JSON.stringify(
        {
          method: req.method,
          query: req.query,
          body: req.body,
        },
        null,
        2,
      ),
    )

    switch (req.method) {
      case 'GET':
        return res.json(
          await prisma.playlist.findMany({
            where: { id },
          }),
        )
      case 'POST':
        return res.json(
          await prisma.playlist.create({
            data: req.body as Prisma.PlaylistCreateInput,
          }),
        )
      case 'PUT':
        return res.json(
          await prisma.playlist.update({
            where: {
              id,
            },
            data: req.body as Prisma.PlaylistUpdateInput,
          }),
        )
      case 'DELETE':
        return res.json(
          await prisma.playlist.delete({
            where: { id },
          }),
        )
    }

    return res
      .status(400)
      .send({ message: \`Unexpected request method: \${req.method}\` })
  } catch (e: any) {
    console.error('[playlist] Error responding:', e)
    return res.status(500).json({ message: e?.message || e })
  }
}",
    "path": "api/playlist.ts",
  },
  "api/song.ts": Object {
    "content": "import { PrismaClient, Prisma } from '@prisma/client'
import { VercelRequest, VercelResponse } from '@vercel/node'

type VercelRequestQuery = {
  id?: string
}

export default async function (req: VercelRequest, res: VercelResponse) {
  try {
    const { id } = req.query as VercelRequestQuery
    const prisma = new PrismaClient()

    console.log(
      '[song] Incoming request:',
      JSON.stringify(
        {
          method: req.method,
          query: req.query,
          body: req.body,
        },
        null,
        2,
      ),
    )

    switch (req.method) {
      case 'GET':
        return res.json(
          await prisma.song.findMany({
            where: { id },
          }),
        )
      case 'POST':
        return res.json(
          await prisma.song.create({
            data: req.body as Prisma.SongCreateInput,
          }),
        )
      case 'PUT':
        return res.json(
          await prisma.song.update({
            where: {
              id,
            },
            data: req.body as Prisma.SongUpdateInput,
          }),
        )
      case 'DELETE':
        return res.json(
          await prisma.song.delete({
            where: { id },
          }),
        )
    }

    return res
      .status(400)
      .send({ message: \`Unexpected request method: \${req.method}\` })
  } catch (e: any) {
    console.error('[song] Error responding:', e)
    return res.status(500).json({ message: e?.message || e })
  }
}",
    "path": "api/song.ts",
  },
  "api/user.ts": Object {
    "content": "import { PrismaClient, Prisma } from '@prisma/client'
import { VercelRequest, VercelResponse } from '@vercel/node'

type VercelRequestQuery = {
  id?: string
}

export default async function (req: VercelRequest, res: VercelResponse) {
  try {
    const { id } = req.query as VercelRequestQuery
    const prisma = new PrismaClient()

    console.log(
      '[user] Incoming request:',
      JSON.stringify(
        {
          method: req.method,
          query: req.query,
          body: req.body,
        },
        null,
        2,
      ),
    )

    switch (req.method) {
      case 'GET':
        return res.json(
          await prisma.user.findMany({
            where: { id },
          }),
        )
      case 'POST':
        return res.json(
          await prisma.user.create({
            data: req.body as Prisma.UserCreateInput,
          }),
        )
      case 'PUT':
        return res.json(
          await prisma.user.update({
            where: {
              id,
            },
            data: req.body as Prisma.UserUpdateInput,
          }),
        )
      case 'DELETE':
        return res.json(
          await prisma.user.delete({
            where: { id },
          }),
        )
    }

    return res
      .status(400)
      .send({ message: \`Unexpected request method: \${req.method}\` })
  } catch (e: any) {
    console.error('[user] Error responding:', e)
    return res.status(500).json({ message: e?.message || e })
  }
}",
    "path": "api/user.ts",
  },
  "package.json": Object {
    "content": "{
  \\"name\\": \\"music-streaming-service\\",
  \\"license\\": \\"UNLICENSED\\",
  \\"devDependencies\\": {
    \\"@types/faker\\": \\"5.5.8\\",
    \\"@types/node\\": \\"16.9.6\\",
    \\"@vercel/node\\": \\"1.12.1\\",
    \\"faker\\": \\"5.5.3\\",
    \\"prisma\\": \\"3.0.1\\",
    \\"ts-node\\": \\"10.2.1\\",
    \\"typescript\\": \\"4.4.3\\"
  },
  \\"prisma\\": {
    \\"seed\\": \\"ts-node ./prisma/seed.ts\\"
  },
  \\"scripts\\": {
    \\"init\\": \\"prisma db push && prisma db seed\\",
    \\"dev\\": \\"ts-node ./sandbox.ts\\"
  },
  \\"dependencies\\": {
    \\"@prisma/client\\": \\"3.0.1\\"
  },
  \\"engines\\": {
    \\"node\\": \\">=12.2.0\\"
  }
}",
    "path": "package.json",
  },
  "prisma/schema.prisma": Object {
    "content": "// Schema for a fictional music streaming service
// This service contains songs, albums, artists & playlists, and tracks user interactions with each of them

datasource db {
  provider = \\"postgresql\\"
  url      = env(\\"DATABASE_URL\\")
}

generator client {
  provider = \\"prisma-client-js\\"
}

model User {
  id           String        @id @default(uuid())
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt
  name         String
  email        String        @unique
  interactions Interaction[]
  playlists    Playlist[]
}

model Interaction {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  songId    String?
  userId    String?
  isLiked   Boolean  @default(false)
  playCount Int
  song      Song?    @relation(fields: [songId], references: [id])
  user      User?    @relation(fields: [userId], references: [id])
}

model Song {
  id           String        @id @default(uuid())
  interactions Interaction[]
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt
  name         String
  album        Album?        @relation(fields: [albumId], references: [id])
  albumId      String?
  artist       Artist        @relation(fields: [artistId], references: [id])
  artistId     String
  length       Float
  track        Int?
  lyrics       String?
  playlist     Playlist[]
  fileUrl      String
}

model Artist {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  name      String
  albums    Album[]
  songs     Song[]
}

model Album {
  id        String   @id @default(uuid())
  songs     Song[]
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  artists   Artist[]
  name      String
  cover     String
}

model Playlist {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  user      User?    @relation(fields: [userId], references: [id])
  userId    String?
  songs     Song[]
  name      String
}",
    "path": "prisma/schema.prisma",
  },
  "prisma/seed.ts": Object {
    "content": "import { PrismaClient } from '@prisma/client'
import * as faker from 'faker'

const MAX_NUMBER_OF_SONGS_PER_ARTIST = 5
const NUMBER_OF_ARTISTS = 5
const NUMBER_OF_USERS = 10

const userIds = Array.from({
  length: NUMBER_OF_USERS,
}).map(() => faker.datatype.uuid())

export async function seed() {
  const prisma = new PrismaClient()

  try {
    // Create artists
    await prisma.artist.createMany({
      data: Array.from({ length: NUMBER_OF_ARTISTS }).map(() => ({
        name: faker.name.firstName(),
      })),
    })

    const artists = await prisma.artist.findMany()

    // Create songs for each artist
    for (const artist of artists) {
      await prisma.album.create({
        data: {
          cover: faker.image.imageUrl(),
          name: faker.random.words(2),
          artists: {
            connect: {
              id: artist.id,
            },
          },
          songs: {
            create: Array.from({
              length: faker.datatype.number({
                min: 2,
                max: MAX_NUMBER_OF_SONGS_PER_ARTIST,
              }),
            }).map(() => ({
              artistId: artist.id,
              fileUrl: faker.internet.url(),
              length: faker.datatype.float(),
              name: faker.name.firstName(),
            })),
          },
        },
      })
    }

    // Create songs
    const songs = await prisma.song.findMany()

    for (const userId of userIds) {
      // Create users
      await prisma.user.create({
        data: {
          id: userId,
          email: faker.internet.email(),
          name: faker.name.firstName(),
          interactions: {
            create: Array.from({
              length: faker.datatype.number({
                min: 3,
                max: songs.length,
              }),
            }).map(() => ({
              playCount: faker.datatype.number({ min: 1, max: 1000 }),
              songId:
                songs[faker.datatype.number({ min: 0, max: songs.length - 1 })]
                  .id,
              // random boolean
              isLiked: Math.random() < 0.5,
            })),
          },
        },
      })

      // Create Playlists
      await prisma.playlist.create({
        data: {
          name: faker.random.words(2),
          user: {
            connect: {
              id: userId,
            },
          },
          // each playlist will have a random list of songs
          songs: {
            connect: songs
              .slice(
                0,
                faker.datatype.number({ min: 1, max: songs.length - 1 }),
              )
              .map(({ id }) => ({ id })),
          },
        },
      })
    }
  } catch (e) {
    await prisma.$disconnect()
    throw e
  } finally {
    await prisma.$disconnect()
  }
}",
    "path": "prisma/seed.ts",
  },
  "public/index.html": Object {
    "content": "<html>
  <head>
    <title>Music Streaming Service Template</title>

    <link rel=\\"icon\\" type=\\"image/svg\\" href=\\"prisma.svg\\" />
    <style>
      @font-face {
        font-family: Inter;
        font-weight: 400;
        src: url('https://cdn.jsdelivr.net/npm/@fontsource/inter/files/inter-latin-400-normal.woff2')
            format('woff2'),
          url('https://cdn.jsdelivr.net/npm/@fontsource/inter/files/inter-latin-400-normal.woff')
            format('woff');
      }

      @font-face {
        font-family: Inter;
        font-weight: 900;
        src: url('https://cdn.jsdelivr.net/npm/@fontsource/inter/files/inter-latin-900-normal.woff2')
            format('woff2'),
          url('https://cdn.jsdelivr.net/npm/@fontsource/inter/files/inter-latin-900-normal.woff')
            format('woff');
      }
    </style>

    <style>
      :root {
        --prisma-blue: #1a202c;
        --white: #ffffff;
        --green: #34d399;
        --black: #000000;
        --gray: rgba(0, 0, 0, 0.75);
      }
    </style>

    <style>
      body {
        margin: 0;
        padding: 0;
        font-size: 16px;
      }
      * {
        box-sizing: border-box;
      }
      h1,
      h2,
      h3,
      h4,
      h5,
      h6,
      p {
        margin: 0;
      }

      #hero {
        background: var(--prisma-blue);
        height: 60%;
        color: var(--white);
        font-family: Inter, sans-serif;
        display: flex;
        flex-direction: column;
        align-items: center;
      }

      #prisma-logo {
        padding: 50px;
      }

      #hero-text {
        display: flex;
        flex-direction: column;
        align-items: center;
        flex: 1;
      }

      #title {
        font-size: 72px;
        font-weight: 900;
        line-height: 1;
      }

      #subtitle {
        font-size: 24px;
        font-weight: 400;
        margin: 20px;
      }
      #subtitle a {
        color: var(--white) !important;
      }

      #docs {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        margin: 0 auto;
        width: 100%;
        padding: 40px;
      }

      #docs .title {
        color: var(--gray);
        font-family: Inter, sans-serif;
        font-weight: 900;
        margin-bottom: 20px;
      }

      #docs article {
        font-family: monospace;
        margin: 40px;
      }
      #docs article h3 {
        font-family: monospace;
        font-size: 24px;
        color: var(--gray);
        text-align: center;
      }

      #docs article ul {
        list-style: none;
      }

      #docs article ul li {
        display: grid;
        grid-template-columns: 1fr 2fr 3fr;
        margin: 10px;
      }
      #docs article ul li .method {
        color: var(--green);
        text-align: right;
        grid-column: 1 / 2;
        margin-right: 20px;
      }
      #docs article ul li .url {
        color: var(--black);
        grid-column: 2 / 3;
        margin-right: 60px;
      }
      #docs article ul li .description {
        color: var(--gray);
        grid-column: 3 / 4;
      }
    </style>
  </head>

  <body>
    <section id=\\"hero\\">
      <header style=\\"flex: 1\\">
        <img src=\\"prisma.svg\\" alt=\\"Prisma logo\\" id=\\"prisma-logo\\" />
      </header>
      <div id=\\"hero-text\\">
        <h1 id=\\"title\\">Music Streaming Service Template</h1>
        <h3 id=\\"subtitle\\">
          Generated by
          <a href=\\"https://cloud.prisma.io\\" target=\\"_blank\\"
            >Prisma Data Platform</a
          >
        </h3>
      </div>
      <div style=\\"flex: 1\\"></div>
    </section>

    <section id=\\"docs\\">
      <h1 class=\\"title\\">API Endpoints</h1>
    </section>

    <script>
      const docs = [
        {
          model: 'User',
          endpoints: [
            {
              method: 'GET',
              url: '/api/user',
              description: 'Get all users',
            },
            {
              method: 'GET',
              url: '/api/user?id=:id',
              description: 'Get a single user',
            },
            {
              method: 'POST',
              url: '/api/userd',
              description: 'Create a single user',
            },
            {
              method: 'PUT',
              url: '/api/user?id=:id',
              description: 'Update a single user',
            },
            {
              method: 'DELETE',
              url: '/api/user?id=:id',
              description: 'Delete a single user',
            },
          ],
        },
        {
          model: 'Interaction',
          endpoints: [
            {
              method: 'GET',
              url: '/api/interaction',
              description: 'Get all interactions',
            },
            {
              method: 'GET',
              url: '/api/interaction?id=:id',
              description: 'Get a single interaction',
            },
            {
              method: 'POST',
              url: '/api/interaction',
              description: 'Create a single interaction',
            },
            {
              method: 'PUT',
              url: '/api/interaction?id=:id',
              description: 'Update a single interaction',
            },
            {
              method: 'DELETE',
              url: '/api/interaction?id=:id',
              description: 'Delete a single interaction',
            },
          ],
        },
        {
          model: 'Song',
          endpoints: [
            {
              method: 'GET',
              url: '/api/song',
              description: 'Get all songs',
            },
            {
              method: 'GET',
              url: '/api/song?id=:id',
              description: 'Get a single song',
            },
            {
              method: 'POST',
              url: '/api/song',
              description: 'Create a single song',
            },
            {
              method: 'PUT',
              url: '/api/song?id=:id',
              description: 'Update a single song',
            },
            {
              method: 'DELETE',
              url: '/api/song?id=:id',
              description: 'Delete a single song',
            },
          ],
        },
        {
          model: 'Artist',
          endpoints: [
            {
              method: 'GET',
              url: '/api/artist',
              description: 'Get all artists',
            },
            {
              method: 'GET',
              url: '/api/artist?id=:id',
              description: 'Get a single artist',
            },
            {
              method: 'POST',
              url: '/api/artist',
              description: 'Create a single artist',
            },
            {
              method: 'PUT',
              url: '/api/artist?id=:id',
              description: 'Update a single artist',
            },
            {
              method: 'DELETE',
              url: '/api/artist?id=:id',
              description: 'Delete a single artist',
            },
          ],
        },
        {
          model: 'Album',
          endpoints: [
            {
              method: 'GET',
              url: '/api/album',
              description: 'Get all albums',
            },
            {
              method: 'GET',
              url: '/api/album?id=:id',
              description: 'Get a single album',
            },
            {
              method: 'POST',
              url: '/api/album',
              description: 'Create a single album',
            },
            {
              method: 'PUT',
              url: '/api/album?id=:id',
              description: 'Update a single album',
            },
            {
              method: 'DELETE',
              url: '/api/album?id=:id',
              description: 'Delete a single album',
            },
          ],
        },
        {
          model: 'Playlist',
          endpoints: [
            {
              method: 'GET',
              url: '/api/playlist',
              description: 'Get all playlists',
            },
            {
              method: 'GET',
              url: '/api/playlist?id=:id',
              description: 'Get a single playlist',
            },
            {
              method: 'POST',
              url: '/api/playlist',
              description: 'Create a single playlist',
            },
            {
              method: 'PUT',
              url: '/api/playlist?id=:id',
              description: 'Update a single playlist',
            },
            {
              method: 'DELETE',
              url: '/api/playlist?id=:id',
              description: 'Delete a single playlist',
            },
          ],
        },
      ]

      // Rendering
      const container = document.getElementById('docs')

      for (const group of docs) {
        const article = document.createElement('article')

        const title = document.createElement('h3')
        title.innerText = group.model
        article.appendChild(title)

        const ul = document.createElement('ul')
        for (const endpoint of group.endpoints) {
          const li = document.createElement('li')
          li.classList.add('endpoint')

          const method = document.createElement('p')
          method.classList.add('method')
          method.innerText = endpoint.method
          li.appendChild(method)

          const url = document.createElement('p')
          url.classList.add('url')
          url.innerText = endpoint.url
          li.appendChild(url)

          const description = document.createElement('p')
          description.classList.add('description')
          description.innerText = endpoint.description
          li.appendChild(description)

          ul.appendChild(li)
        }
        article.appendChild(ul)

        container.appendChild(article)
      }
    </script>
  </body>
</html>",
    "path": "public/index.html",
  },
  "public/prisma.svg": Object {
    "content": "<svg width=\\"32\\" height=\\"40\\" viewBox=\\"0 0 32 40\\" fill=\\"none\\" xmlns=\\"http://www.w3.org/2000/svg\\">
<path fill-rule=\\"evenodd\\" clip-rule=\\"evenodd\\" d=\\"M0.28825 24.9389C-0.101619 25.5764 -0.0955847 26.3808 0.303803 27.0124L7.5326 38.4434C8.00176 39.1853 8.90609 39.5236 9.74539 39.2712L30.606 32.9977C31.7444 32.6554 32.3172 31.3823 31.8196 30.3003L18.4094 1.13932C17.7554 -0.282788 15.7839 -0.399522 14.9675 0.935524L0.28825 24.9389ZM18.1058 7.79741C17.8205 7.13653 16.854 7.23832 16.7124 7.94418L11.5428 33.7038C11.4338 34.247 11.9419 34.7108 12.4724 34.5524L26.9042 30.2411C27.3254 30.1153 27.5424 29.6497 27.368 29.2458L18.1058 7.79741Z\\" fill=\\"white\\"/>
</svg>",
    "path": "public/prisma.svg",
  },
  "sandbox.ts": Object {
    "content": "import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient()

const main = async () => {
  const albums = await prisma.album.findMany({
    where: {
      name: {
        contains: ' '
      }
    }
  })

  console.log('Albums that have more than 1 word: ', albums)
}

main()
  .catch((e) => console.error('Error in Prisma Client query: ', e))
  .finally(async () => await prisma.$disconnect())",
    "path": "sandbox.ts",
  },
  "tsconfig.json": Object {
    "content": "{
  \\"compilerOptions\\": {
    \\"sourceMap\\": true,
    \\"outDir\\": \\"dist\\",
    \\"strict\\": true,
    \\"lib\\": [\\"esnext\\", \\"dom\\"],
    \\"esModuleInterop\\": true
  }
}",
    "path": "tsconfig.json",
  },
}
`;

exports[`Template classes have static data files rentalsPlatform 1`] = `
Object {
  "README.md": Object {
    "content": "# Rentals Platform

![Database Diagram](https://github.com/prisma/prisma-schema-examples/blob/main/rentalsPlatform/diagram.png?raw=true)

(Generated via https://github.com/notiz-dev/prisma-dbml-generator + https://dbdiagram.io)

### Setting this project up locally

Once you clone your repo, you'll want to set up this repo for local development. In order to start using Prisma locally, you need to make Prisma aware of your database. The most portable way to do this is to use environment variables via a \`.env\` file.

1. You'll see that your Prisma Schema file (at \`prisma/schema.prisma\`) is already configured to use an environment variable called \`DATABASE_URL\`. [Read more about environment variables in Prisma](https://www.prisma.io/docs/concepts/more/environment-variables)
2. You'll need a database to connect to. You may use the same one you used while setting this project up on the Prisma Data Platform, but we recommend setting up a local database and use that during development. If you're new to databases, we recommend [reading up](https://www.prisma.io/dataguide/) on them. This guide also has instructions on how to set up a local database.
3. Once you have a locally accessible database connection string, create a new file called \`.env\` in the \`prisma\` directory, and populate it with: \`DATABASE_URL=\\"<replace-me-with-your-connection-string>\\"\`. Prisma will automatically pick up the environment variable used in the schema and use its value to connect to your database.
4. Now you can run \`npm run init\` to set up your local database. This will create tables corresponding to models in your Prisma Schema and populate them with fake data for you to play around with.
   - [Read more about the Prisma Schema](https://www.prisma.io/docs/concepts/components/prisma-schema)
   - [Read more about database seeding](https://www.prisma.io/docs/guides/database/seed-database)

To learn more about Prisma, we recommend reading through our [Getting Started guide](https://www.prisma.io/docs/getting-started)",
    "path": "README.md",
  },
  "api/media.ts": Object {
    "content": "import { PrismaClient, Prisma } from '@prisma/client'
import { VercelRequest, VercelResponse } from '@vercel/node'

type VercelRequestQuery = {
  id?: string
}

export default async function (req: VercelRequest, res: VercelResponse) {
  try {
    const { id } = req.query as VercelRequestQuery
    const prisma = new PrismaClient()

    console.log(
      '[media] Incoming request:',
      JSON.stringify(
        {
          method: req.method,
          query: req.query,
          body: req.body,
        },
        null,
        2,
      ),
    )

    switch (req.method) {
      case 'GET':
        return res.json(
          await prisma.media.findMany({
            where: { id },
          }),
        )
      case 'POST':
        return res.json(
          await prisma.media.create({
            data: req.body as Prisma.MediaCreateInput,
          }),
        )
      case 'PUT':
        return res.json(
          await prisma.media.update({
            where: {
              id,
            },
            data: req.body as Prisma.MediaUpdateInput,
          }),
        )
      case 'DELETE':
        return res.json(
          await prisma.media.delete({
            where: { id },
          }),
        )
    }

    return res
      .status(400)
      .send({ message: \`Unexpected request method: \${req.method}\` })
  } catch (e: any) {
    console.error('[media] Error responding:', e)
    return res.status(500).json({ message: e?.message || e })
  }
}",
    "path": "api/media.ts",
  },
  "api/reservation.ts": Object {
    "content": "import { PrismaClient, Prisma } from '@prisma/client'
import { VercelRequest, VercelResponse } from '@vercel/node'

type VercelRequestQuery = {
  id?: string
}

export default async function (req: VercelRequest, res: VercelResponse) {
  try {
    const { id } = req.query as VercelRequestQuery
    const prisma = new PrismaClient()

    console.log(
      '[reservation] Incoming request:',
      JSON.stringify(
        {
          method: req.method,
          query: req.query,
          body: req.body,
        },
        null,
        2,
      ),
    )

    switch (req.method) {
      case 'GET':
        return res.json(
          await prisma.reservation.findMany({
            where: { id },
          }),
        )
      case 'POST':
        return res.json(
          await prisma.reservation.create({
            data: req.body as Prisma.ReservationCreateInput,
          }),
        )
      case 'PUT':
        return res.json(
          await prisma.reservation.update({
            where: {
              id,
            },
            data: req.body as Prisma.ReservationUpdateInput,
          }),
        )
      case 'DELETE':
        return res.json(
          await prisma.reservation.delete({
            where: { id },
          }),
        )
    }

    return res
      .status(400)
      .send({ message: \`Unexpected request method: \${req.method}\` })
  } catch (e: any) {
    console.error('[reservation] Error responding:', e)
    return res.status(500).json({ message: e?.message || e })
  }
}",
    "path": "api/reservation.ts",
  },
  "api/review.ts": Object {
    "content": "import { PrismaClient, Prisma } from '@prisma/client'
import { VercelRequest, VercelResponse } from '@vercel/node'

type VercelRequestQuery = {
  id?: string
}

export default async function (req: VercelRequest, res: VercelResponse) {
  try {
    const { id } = req.query as VercelRequestQuery
    const prisma = new PrismaClient()

    console.log(
      '[review] Incoming request:',
      JSON.stringify(
        {
          method: req.method,
          query: req.query,
          body: req.body,
        },
        null,
        2,
      ),
    )

    switch (req.method) {
      case 'GET':
        return res.json(
          await prisma.review.findMany({
            where: { id },
          }),
        )
      case 'POST':
        return res.json(
          await prisma.review.create({
            data: req.body as Prisma.ReviewCreateInput,
          }),
        )
      case 'PUT':
        return res.json(
          await prisma.review.update({
            where: {
              id,
            },
            data: req.body as Prisma.ReviewUpdateInput,
          }),
        )
      case 'DELETE':
        return res.json(
          await prisma.review.delete({
            where: { id },
          }),
        )
    }

    return res
      .status(400)
      .send({ message: \`Unexpected request method: \${req.method}\` })
  } catch (e: any) {
    console.error('[review] Error responding:', e)
    return res.status(500).json({ message: e?.message || e })
  }
}",
    "path": "api/review.ts",
  },
  "api/room.ts": Object {
    "content": "import { PrismaClient, Prisma } from '@prisma/client'
import { VercelRequest, VercelResponse } from '@vercel/node'

type VercelRequestQuery = {
  id?: string
}

export default async function (req: VercelRequest, res: VercelResponse) {
  try {
    const { id } = req.query as VercelRequestQuery
    const prisma = new PrismaClient()

    console.log(
      '[room] Incoming request:',
      JSON.stringify(
        {
          method: req.method,
          query: req.query,
          body: req.body,
        },
        null,
        2,
      ),
    )

    switch (req.method) {
      case 'GET':
        return res.json(
          await prisma.room.findMany({
            where: { id },
          }),
        )
      case 'POST':
        return res.json(
          await prisma.room.create({
            data: req.body as Prisma.RoomCreateInput,
          }),
        )
      case 'PUT':
        return res.json(
          await prisma.room.update({
            where: {
              id,
            },
            data: req.body as Prisma.RoomUpdateInput,
          }),
        )
      case 'DELETE':
        return res.json(
          await prisma.room.delete({
            where: { id },
          }),
        )
    }

    return res
      .status(400)
      .send({ message: \`Unexpected request method: \${req.method}\` })
  } catch (e: any) {
    console.error('[room] Error responding:', e)
    return res.status(500).json({ message: e?.message || e })
  }
}",
    "path": "api/room.ts",
  },
  "api/user.ts": Object {
    "content": "import { PrismaClient, Prisma } from '@prisma/client'
import { VercelRequest, VercelResponse } from '@vercel/node'

type VercelRequestQuery = {
  id?: string
}

export default async function (req: VercelRequest, res: VercelResponse) {
  try {
    const { id } = req.query as VercelRequestQuery
    const prisma = new PrismaClient()

    console.log(
      '[user] Incoming request:',
      JSON.stringify(
        {
          method: req.method,
          query: req.query,
          body: req.body,
        },
        null,
        2,
      ),
    )

    switch (req.method) {
      case 'GET':
        return res.json(
          await prisma.user.findMany({
            where: { id },
          }),
        )
      case 'POST':
        return res.json(
          await prisma.user.create({
            data: req.body as Prisma.UserCreateInput,
          }),
        )
      case 'PUT':
        return res.json(
          await prisma.user.update({
            where: {
              id,
            },
            data: req.body as Prisma.UserUpdateInput,
          }),
        )
      case 'DELETE':
        return res.json(
          await prisma.user.delete({
            where: { id },
          }),
        )
    }

    return res
      .status(400)
      .send({ message: \`Unexpected request method: \${req.method}\` })
  } catch (e: any) {
    console.error('[user] Error responding:', e)
    return res.status(500).json({ message: e?.message || e })
  }
}",
    "path": "api/user.ts",
  },
  "package.json": Object {
    "content": "{
  \\"name\\": \\"rentals-platform\\",
  \\"license\\": \\"UNLICENSED\\",
  \\"devDependencies\\": {
    \\"@types/faker\\": \\"5.5.8\\",
    \\"@types/node\\": \\"16.9.6\\",
    \\"@vercel/node\\": \\"1.12.1\\",
    \\"faker\\": \\"5.5.3\\",
    \\"prisma\\": \\"3.0.1\\",
    \\"ts-node\\": \\"10.2.1\\",
    \\"typescript\\": \\"4.4.3\\"
  },
  \\"prisma\\": {
    \\"seed\\": \\"ts-node ./prisma/seed.ts\\"
  },
  \\"scripts\\": {
    \\"init\\": \\"prisma db push && prisma db seed\\",
    \\"dev\\": \\"ts-node ./sandbox.ts\\"
  },
  \\"dependencies\\": {
    \\"@prisma/client\\": \\"3.0.1\\"
  },
  \\"engines\\": {
    \\"node\\": \\">=12.2.0\\"
  }
}",
    "path": "package.json",
  },
  "prisma/schema.prisma": Object {
    "content": "// Schema for a fictional hotel
// This hotel tracks rooms, user reservations & reviews

datasource db {
  provider = \\"postgresql\\"
  url      = env(\\"DATABASE_URL\\")
}

generator client {
  provider = \\"prisma-client-js\\"
}

model User {
  id           String        @id @default(uuid())
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt
  email        String        @unique
  name         String
  reservations Reservation[]
  reviews      Review[]
}

model Reservation {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  userId    String?
  user      User?    @relation(fields: [userId], references: [id])
  startDate DateTime
  endDate   DateTime
  price     Int
  total     Int
  room      Room?    @relation(fields: [roomId], references: [id])
  roomId    String?
}

model Room {
  id                 String        @id @default(uuid())
  createdAt          DateTime      @default(now())
  updatedAt          DateTime      @updatedAt
  reservations       Reservation[]
  totalOccupancy     Int           @default(5)
  totalBedrooms      Int           @default(5)
  totalBathrooms     Int           @default(5)
  summary            String?
  address            String
  isSmoking          Boolean       @default(false)
  hasTV              Boolean       @default(true)
  hasAirConditioning Boolean       @default(true)
  hasHeating         Boolean       @default(true)
  hasWIFI            Boolean       @default(true)
  price              Int
  media              Media[]
}

model Review {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  rating    Int
  comment   String
  user      User     @relation(fields: [userId], references: [id])
  userId    String
}

model Media {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  room      Room?    @relation(fields: [roomId], references: [id])
  roomId    String?
  fileName  String
}",
    "path": "prisma/schema.prisma",
  },
  "prisma/seed.ts": Object {
    "content": "import { PrismaClient } from '@prisma/client'

import * as faker from 'faker'

const NUMBER_OF_USERS = 10
const NUMBER_OF_ROOMS = 20

const roomIds = Array.from({
  length: NUMBER_OF_ROOMS,
}).map(() => faker.datatype.uuid())

const rooms = Array.from({
  length: NUMBER_OF_ROOMS,
}).map((_, i) => ({
  id: roomIds[i],
  price: faker.datatype.number({
    min: 50,
    max: 600,
  }),
  // random address - example: b-365
  address: \`\${faker.address.streetPrefix()}-\${faker.datatype.number({
    min: 300,
    max: 1,
  })}\`,
  totalOccupancy: faker.datatype.number({ min: 1, max: 5 }),
  totalBedrooms: faker.datatype.number({ min: 1, max: 5 }),
  totalBathrooms: faker.datatype.number({ min: 1, max: 5 }),
  summary: faker.lorem.paragraph(),
  media: Array.from({
    length: faker.datatype.number({ min: 1, max: 5 }),
  }).map(() => ({
    fileName: faker.image.imageUrl(),
  })),
}))

const users = Array.from({ length: NUMBER_OF_USERS }).map(() => ({
  email: faker.internet.email(),
  name: faker.name.firstName(),
  reviews: Array.from({
    length: faker.datatype.number({
      max: 1,
      min: 4,
    }),
  }).map(() => ({
    comment: faker.lorem.paragraph(),
    rating: faker.datatype.number({
      max: 1,
      min: 5,
    }),
  })),
  // create random reservations per user
  reservations: Array.from({
    length: faker.datatype.number({
      min: 1,
      max: 4,
    }),
  }).map(() => {
    const startDate = faker.date.past()
    const endDate = faker.date.future()
    const price = faker.datatype.number({
      min: 50,
      max: 600,
    })
    return {
      startDate,
      endDate,
      price,
      total:
        Math.ceil(Math.abs(+endDate - +startDate) / (1000 * 60 * 60 * 24)) *
        price, // difference between dates * price
      room: {
        connect: {
          id: roomIds[
            faker.datatype.number({
              min: 0,
              max: NUMBER_OF_ROOMS - 1,
            })
          ],
        },
      },
    }
  }),
}))

export async function seed() {
  const prisma = new PrismaClient()

  try {
    for (let room of rooms) {
      await prisma.room.create({
        data: {
          id: room.id,
          address: room.address,
          price: room.price,
          summary: room.summary,
          media: {
            create: room.media,
          },
        },
      })
    }

    for (let user of users) {
      await prisma.user.create({
        data: {
          email: user.email,
          name: user.name,
          reservations: {
            create: user.reservations,
          },
          reviews: {
            create: user.reviews,
          },
        },
      })
    }
  } catch (e) {
    await prisma.$disconnect()
    throw e
  } finally {
    await prisma.$disconnect()
  }
}",
    "path": "prisma/seed.ts",
  },
  "public/index.html": Object {
    "content": "<html>
  <head>
    <title>Rentals Platform Template</title>

    <link rel=\\"icon\\" type=\\"image/svg\\" href=\\"prisma.svg\\" />
    <style>
      @font-face {
        font-family: Inter;
        font-weight: 400;
        src: url('https://cdn.jsdelivr.net/npm/@fontsource/inter/files/inter-latin-400-normal.woff2')
            format('woff2'),
          url('https://cdn.jsdelivr.net/npm/@fontsource/inter/files/inter-latin-400-normal.woff')
            format('woff');
      }

      @font-face {
        font-family: Inter;
        font-weight: 900;
        src: url('https://cdn.jsdelivr.net/npm/@fontsource/inter/files/inter-latin-900-normal.woff2')
            format('woff2'),
          url('https://cdn.jsdelivr.net/npm/@fontsource/inter/files/inter-latin-900-normal.woff')
            format('woff');
      }
    </style>

    <style>
      :root {
        --prisma-blue: #1a202c;
        --white: #ffffff;
        --green: #34d399;
        --black: #000000;
        --gray: rgba(0, 0, 0, 0.75);
      }
    </style>

    <style>
      body {
        margin: 0;
        padding: 0;
        font-size: 16px;
      }
      * {
        box-sizing: border-box;
      }
      h1,
      h2,
      h3,
      h4,
      h5,
      h6,
      p {
        margin: 0;
      }

      #hero {
        background: var(--prisma-blue);
        height: 60%;
        color: var(--white);
        font-family: Inter, sans-serif;
        display: flex;
        flex-direction: column;
        align-items: center;
      }

      #prisma-logo {
        padding: 50px;
      }

      #hero-text {
        display: flex;
        flex-direction: column;
        align-items: center;
        flex: 1;
      }

      #title {
        font-size: 72px;
        font-weight: 900;
        line-height: 1;
        text-align: center;
      }

      #subtitle {
        font-size: 24px;
        font-weight: 400;
        margin: 20px;
        text-align: center;
      }
      #subtitle a {
        color: var(--white) !important;
      }

      #docs {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        margin: 0 auto;
        width: 100%;
        padding: 40px;
      }

      #docs .title {
        color: var(--gray);
        font-family: Inter, sans-serif;
        font-weight: 900;
        margin-bottom: 20px;
      }

      #docs article {
        font-family: monospace;
        margin: 40px;
      }
      #docs article h3 {
        font-family: monospace;
        font-size: 24px;
        color: var(--gray);
        text-align: center;
      }

      #docs article ul {
        list-style: none;
      }

      #docs article ul li {
        display: grid;
        grid-template-columns: 1fr 2fr 3fr;
        margin: 10px;
      }
      #docs article ul li .method {
        color: var(--green);
        text-align: right;
        grid-column: 1 / 2;
        margin-right: 20px;
      }
      #docs article ul li .url {
        color: var(--black);
        grid-column: 2 / 3;
        margin-right: 60px;
      }
      #docs article ul li .description {
        color: var(--gray);
        grid-column: 3 / 4;
      }
    </style>
  </head>

  <body>
    <section id=\\"hero\\">
      <header style=\\"flex: 1\\">
        <img src=\\"prisma.svg\\" alt=\\"Prisma logo\\" id=\\"prisma-logo\\" />
      </header>
      <div id=\\"hero-text\\">
        <h1 id=\\"title\\">Rentals Platform Template</h1>
        <h3 id=\\"subtitle\\">
          Generated by
          <a href=\\"https://cloud.prisma.io\\" target=\\"_blank\\"
            >Prisma Data Platform</a
          >
        </h3>
      </div>
      <div style=\\"flex: 1\\"></div>
    </section>

    <section id=\\"docs\\">
      <h1 class=\\"title\\">API Endpoints</h1>
    </section>

    <script>
      const docs = [
        {
          model: 'User',
          endpoints: [
            {
              method: 'GET',
              url: '/api/users',
              description: 'Get all users',
            },
            {
              method: 'GET',
              url: '/api/users?id=:id',
              description: 'Get a single user',
            },
            {
              method: 'POST',
              url: '/api/usersd',
              description: 'Create a single user',
            },
            {
              method: 'PUT',
              url: '/api/users?id=:id',
              description: 'Update a single user',
            },
            {
              method: 'DELETE',
              url: '/api/users?id=:id',
              description: 'Delete a single user',
            },
          ],
        },
        {
          model: 'Reservation',
          endpoints: [
            {
              method: 'GET',
              url: '/api/reservation',
              description: 'Get all reservation',
            },
            {
              method: 'GET',
              url: '/api/reservation?id=:id',
              description: 'Get a single account',
            },
            {
              method: 'POST',
              url: '/api/reservationd',
              description: 'Create a single account',
            },
            {
              method: 'PUT',
              url: '/api/reservation?id=:id',
              description: 'Update a single account',
            },
            {
              method: 'DELETE',
              url: '/api/reservation?id=:id',
              description: 'Delete a single account',
            },
          ],
        },
        {
          model: 'Room',
          endpoints: [
            {
              method: 'GET',
              url: '/api/room',
              description: 'Get all rooms',
            },
            {
              method: 'GET',
              url: '/api/room?id=:id',
              description: 'Get a single room',
            },
            {
              method: 'POST',
              url: '/api/room',
              description: 'Create a single room',
            },
            {
              method: 'PUT',
              url: '/api/room?id=:id',
              description: 'Update a single room',
            },
            {
              method: 'DELETE',
              url: '/api/room?id=:id',
              description: 'Delete a single room',
            },
          ],
        },
        {
          model: 'Review',
          endpoints: [
            {
              method: 'GET',
              url: '/api/review',
              description: 'Get all reviews',
            },
            {
              method: 'GET',
              url: '/api/review?id=:id',
              description: 'Get a single review',
            },
            {
              method: 'POST',
              url: '/api/review',
              description: 'Create a single review',
            },
            {
              method: 'PUT',
              url: '/api/review?id=:id',
              description: 'Update a single review',
            },
            {
              method: 'DELETE',
              url: '/api/review?id=:id',
              description: 'Delete a single review',
            },
          ],
        },
        {
          model: 'Media',
          endpoints: [
            {
              method: 'GET',
              url: '/api/media',
              description: 'Get all media',
            },
            {
              method: 'GET',
              url: '/api/media?id=:id',
              description: 'Get a single media',
            },
            {
              method: 'POST',
              url: '/api/media',
              description: 'Create a single media',
            },
            {
              method: 'PUT',
              url: '/api/media?id=:id',
              description: 'Update a single media',
            },
            {
              method: 'DELETE',
              url: '/api/media?id=:id',
              description: 'Delete a single media',
            },
          ],
        },
      ]

      // Rendering
      const container = document.getElementById('docs')

      for (const group of docs) {
        const article = document.createElement('article')

        const title = document.createElement('h3')
        title.innerText = group.model
        article.appendChild(title)

        const ul = document.createElement('ul')
        for (const endpoint of group.endpoints) {
          const li = document.createElement('li')
          li.classList.add('endpoint')

          const method = document.createElement('p')
          method.classList.add('method')
          method.innerText = endpoint.method
          li.appendChild(method)

          const url = document.createElement('p')
          url.classList.add('url')
          url.innerText = endpoint.url
          li.appendChild(url)

          const description = document.createElement('p')
          description.classList.add('description')
          description.innerText = endpoint.description
          li.appendChild(description)

          ul.appendChild(li)
        }
        article.appendChild(ul)

        container.appendChild(article)
      }
    </script>
  </body>
</html>",
    "path": "public/index.html",
  },
  "public/prisma.svg": Object {
    "content": "<svg width=\\"32\\" height=\\"40\\" viewBox=\\"0 0 32 40\\" fill=\\"none\\" xmlns=\\"http://www.w3.org/2000/svg\\">
<path fill-rule=\\"evenodd\\" clip-rule=\\"evenodd\\" d=\\"M0.28825 24.9389C-0.101619 25.5764 -0.0955847 26.3808 0.303803 27.0124L7.5326 38.4434C8.00176 39.1853 8.90609 39.5236 9.74539 39.2712L30.606 32.9977C31.7444 32.6554 32.3172 31.3823 31.8196 30.3003L18.4094 1.13932C17.7554 -0.282788 15.7839 -0.399522 14.9675 0.935524L0.28825 24.9389ZM18.1058 7.79741C17.8205 7.13653 16.854 7.23832 16.7124 7.94418L11.5428 33.7038C11.4338 34.247 11.9419 34.7108 12.4724 34.5524L26.9042 30.2411C27.3254 30.1153 27.5424 29.6497 27.368 29.2458L18.1058 7.79741Z\\" fill=\\"white\\"/>
</svg>",
    "path": "public/prisma.svg",
  },
  "sandbox.ts": Object {
    "content": "import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient()

const main = async () => {
  const reservations = await prisma.reservation.findMany({
    where: {
      price: {
        gte: 300,
      },
    },
  })

  console.log('Expensive reservations: ', reservations)
}

main()
  .catch((e) => console.error('Error in Prisma Client query: ', e))
  .finally(async () => await prisma.$disconnect())",
    "path": "sandbox.ts",
  },
  "tsconfig.json": Object {
    "content": "{
  \\"compilerOptions\\": {
    \\"sourceMap\\": true,
    \\"outDir\\": \\"dist\\",
    \\"strict\\": true,
    \\"lib\\": [\\"esnext\\", \\"dom\\"],
    \\"esModuleInterop\\": true
  }
}",
    "path": "tsconfig.json",
  },
}
`;

exports[`Template classes have static data files saas 1`] = `
Object {
  "README.md": Object {
    "content": "# SaaS

Generic Prisma schema example for a SaaS that has a referral system.

![Database diagram](https://raw.githubusercontent.com/prisma/prisma-schema-examples/main/saas/diagram.png)

(Generated via https://github.com/notiz-dev/prisma-dbml-generator + https://dbdiagram.io)

### Setting this project up locally

Once you clone your repo, you'll want to set up this repo for local development. In order to start using Prisma locally, you need to make Prisma aware of your database. The most portable way to do this is to use environment variables via a \`.env\` file.

1. You'll see that your Prisma Schema file (at \`prisma/schema.prisma\`) is already configured to use an environment variable called \`DATABASE_URL\`. [Read more about environment variables in Prisma](https://www.prisma.io/docs/concepts/more/environment-variables)
2. You'll need a database to connect to. You may use the same one you used while setting this project up on the Prisma Data Platform, but we recommend setting up a local database and use that during development. If you're new to databases, we recommend [reading up](https://www.prisma.io/dataguide/) on them. This guide also has instructions on how to set up a local database.
3. Once you have a locally accessible database connection string, create a new file called \`.env\` in the \`prisma\` directory, and populate it with: \`DATABASE_URL=\\"<replace-me-with-your-connection-string>\\"\`. Prisma will automatically pick up the environment variable used in the schema and use its value to connect to your database.
4. Now you can run \`npm run init\` to set up your local database. This will create tables corresponding to models in your Prisma Schema and populate them with fake data for you to play around with.
   - [Read more about the Prisma Schema](https://www.prisma.io/docs/concepts/components/prisma-schema)
   - [Read more about database seeding](https://www.prisma.io/docs/guides/database/seed-database)

To learn more about Prisma, we recommend reading through our [Getting Started guide](https://www.prisma.io/docs/getting-started)",
    "path": "README.md",
  },
  "api/account.ts": Object {
    "content": "import { PrismaClient, Prisma } from '@prisma/client'
import { VercelRequest, VercelResponse } from '@vercel/node'

type VercelRequestQuery = {
  id?: string
}

export default async function (req: VercelRequest, res: VercelResponse) {
  try {
    const { id } = req.query as VercelRequestQuery
    const prisma = new PrismaClient()

    console.log(
      '[account] Incoming request:',
      JSON.stringify(
        {
          method: req.method,
          query: req.query,
          body: req.body,
        },
        null,
        2,
      ),
    )

    switch (req.method) {
      case 'GET':
        return res.json(
          await prisma.account.findMany({
            where: { id },
          }),
        )
      case 'POST':
        return res.json(
          await prisma.account.create({
            data: req.body as Prisma.AccountCreateInput,
          }),
        )
      case 'PUT':
        return res.json(
          await prisma.account.update({
            where: {
              id,
            },
            data: req.body as Prisma.AccountUpdateInput,
          }),
        )
      case 'DELETE':
        return res.json(
          await prisma.account.delete({
            where: { id },
          }),
        )
    }

    return res
      .status(400)
      .send({ message: \`Unexpected request method: \${req.method}\` })
  } catch (e: any) {
    console.error('[account] Error responding:', e)
    return res.status(500).json({ message: e?.message || e })
  }
}",
    "path": "api/account.ts",
  },
  "api/invite.ts": Object {
    "content": "import { PrismaClient, Prisma } from '@prisma/client'
import { VercelRequest, VercelResponse } from '@vercel/node'

type VercelRequestQuery = {
  id?: string
}

export default async function (req: VercelRequest, res: VercelResponse) {
  try {
    const { id } = req.query as VercelRequestQuery
    const prisma = new PrismaClient()

    console.log(
      '[invite] Incoming request:',
      JSON.stringify(
        {
          method: req.method,
          query: req.query,
          body: req.body,
        },
        null,
        2,
      ),
    )

    switch (req.method) {
      case 'GET':
        return res.json(
          await prisma.invite.findMany({
            where: { id },
          }),
        )
      case 'POST':
        return res.json(
          await prisma.invite.create({
            data: req.body as Prisma.InviteCreateInput,
          }),
        )
      case 'PUT':
        return res.json(
          await prisma.invite.update({
            where: {
              id,
            },
            data: req.body as Prisma.InviteUpdateInput,
          }),
        )
      case 'DELETE':
        return res.json(
          await prisma.invite.delete({
            where: { id },
          }),
        )
    }

    return res
      .status(400)
      .send({ message: \`Unexpected request method: \${req.method}\` })
  } catch (e: any) {
    console.error('[invite] Error responding:', e)
    return res.status(500).json({ message: e?.message || e })
  }
}",
    "path": "api/invite.ts",
  },
  "api/user.ts": Object {
    "content": "import { PrismaClient, Prisma } from '@prisma/client'
import { VercelRequest, VercelResponse } from '@vercel/node'

type VercelRequestQuery = {
  id?: string
}

export default async function (req: VercelRequest, res: VercelResponse) {
  try {
    const { id } = req.query as VercelRequestQuery
    const prisma = new PrismaClient()

    console.log(
      '[user] Incoming request:',
      JSON.stringify(
        {
          method: req.method,
          query: req.query,
          body: req.body,
        },
        null,
        2,
      ),
    )

    switch (req.method) {
      case 'GET':
        return res.json(
          await prisma.user.findMany({
            where: { id },
          }),
        )
      case 'POST':
        return res.json(
          await prisma.user.create({
            data: req.body as Prisma.UserCreateInput,
          }),
        )
      case 'PUT':
        return res.json(
          await prisma.user.update({
            where: {
              id,
            },
            data: req.body as Prisma.UserUpdateInput,
          }),
        )
      case 'DELETE':
        return res.json(
          await prisma.user.delete({
            where: { id },
          }),
        )
    }

    return res
      .status(400)
      .send({ message: \`Unexpected request method: \${req.method}\` })
  } catch (e: any) {
    console.error('[user] Error responding:', e)
    return res.status(500).json({ message: e?.message || e })
  }
}",
    "path": "api/user.ts",
  },
  "package.json": Object {
    "content": "{
  \\"name\\": \\"saas\\",
  \\"license\\": \\"UNLICENSED\\",
  \\"devDependencies\\": {
    \\"@types/faker\\": \\"5.5.8\\",
    \\"@types/node\\": \\"16.9.6\\",
    \\"@vercel/node\\": \\"1.12.1\\",
    \\"faker\\": \\"5.5.3\\",
    \\"prisma\\": \\"3.0.1\\",
    \\"ts-node\\": \\"10.2.1\\",
    \\"typescript\\": \\"4.4.3\\"
  },
  \\"prisma\\": {
    \\"seed\\": \\"ts-node ./prisma/seed.ts\\"
  },
  \\"scripts\\": {
    \\"init\\": \\"prisma db push && prisma db seed\\",
    \\"dev\\": \\"ts-node ./sandbox.ts\\"
  },
  \\"dependencies\\": {
    \\"@prisma/client\\": \\"3.0.1\\"
  },
  \\"engines\\": {
    \\"node\\": \\">=12.2.0\\"
  }
}",
    "path": "package.json",
  },
  "prisma/schema.prisma": Object {
    "content": "// Schema for an identity service for a SaaS
// This service tracks existing users & their accounts, as well as invites for users who haven't joined yet

datasource db {
  provider = \\"postgresql\\"
  url      = env(\\"DATABASE_URL\\")
}

generator client {
  provider = \\"prisma-client-js\\"
}

model User {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  name      String?
  email     String
  account   Account? @relation(fields: [accountId], references: [id])
  accountId String?
}

model Account {
  id                   String   @id @default(uuid())
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt
  invites              Invite[]
  users                User[]
  stripeCustomerId     String
  stripeSubscriptionId String
  referrer             String?
  isActive             Boolean
}

model Invite {
  id        String   @id @default(uuid())
  dateSent  DateTime @default(now())
  email     String
  account   Account? @relation(fields: [accountId], references: [id])
  accountId String?
  isValid   Boolean  @default(true)
}",
    "path": "prisma/schema.prisma",
  },
  "prisma/seed.ts": Object {
    "content": "import { PrismaClient } from '@prisma/client'
import * as faker from 'faker'

const NUMBER_OF_USERS = 4
const NUMBER_OF_INVITES = 4

const data = Array.from({ length: NUMBER_OF_USERS }).map(() => ({
  email: faker.internet.email(),
  name: faker.name.firstName(),
  account: {
    stripeCustomerId: faker.datatype.uuid(),
    stripeSubscriptionId: faker.datatype.uuid(),
    isActive: true,
  },
  invites: Array.from({
    length: faker.datatype.number({ min: 0, max: NUMBER_OF_INVITES }),
  }).map(() => ({
    email: faker.internet.email(),
    dateSent: faker.date.future(),
  })),
}))

export async function seed() {
  const prisma = new PrismaClient()

  try {
    for (let entry of data) {
      await prisma.user.create({
        data: {
          name: entry.name,
          email: entry.email,
          account: {
            create: {
              stripeCustomerId: entry.account.stripeCustomerId,
              stripeSubscriptionId: entry.account.stripeSubscriptionId,
              isActive: true,
              invites: {
                create: entry.invites,
              },
            },
          },
        },
      })
    }
  } catch (e) {
    await prisma.$disconnect()
    throw e
  } finally {
    await prisma.$disconnect()
  }
}",
    "path": "prisma/seed.ts",
  },
  "public/index.html": Object {
    "content": "<html>
  <head>
    <title>SaaS Template</title>

    <link rel=\\"icon\\" type=\\"image/svg\\" href=\\"prisma.svg\\" />
    <style>
      @font-face {
        font-family: Inter;
        font-weight: 400;
        src: url('https://cdn.jsdelivr.net/npm/@fontsource/inter/files/inter-latin-400-normal.woff2')
            format('woff2'),
          url('https://cdn.jsdelivr.net/npm/@fontsource/inter/files/inter-latin-400-normal.woff')
            format('woff');
      }

      @font-face {
        font-family: Inter;
        font-weight: 900;
        src: url('https://cdn.jsdelivr.net/npm/@fontsource/inter/files/inter-latin-900-normal.woff2')
            format('woff2'),
          url('https://cdn.jsdelivr.net/npm/@fontsource/inter/files/inter-latin-900-normal.woff')
            format('woff');
      }
    </style>

    <style>
      :root {
        --prisma-blue: #1a202c;
        --white: #ffffff;
        --green: #34d399;
        --black: #000000;
        --gray: rgba(0, 0, 0, 0.75);
      }
    </style>

    <style>
      body {
        margin: 0;
        padding: 0;
        font-size: 16px;
      }
      * {
        box-sizing: border-box;
      }
      h1,
      h2,
      h3,
      h4,
      h5,
      h6,
      p {
        margin: 0;
      }

      #hero {
        background: var(--prisma-blue);
        height: 60%;
        color: var(--white);
        font-family: Inter, sans-serif;
        display: flex;
        flex-direction: column;
        align-items: center;
      }

      #prisma-logo {
        padding: 50px;
      }

      #hero-text {
        display: flex;
        flex-direction: column;
        align-items: center;
        flex: 1;
      }

      #title {
        font-size: 72px;
        font-weight: 900;
        line-height: 1;
      }

      #subtitle {
        font-size: 24px;
        font-weight: 400;
        margin: 20px;
      }
      #subtitle a {
        color: var(--white) !important;
      }

      #docs {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        margin: 0 auto;
        width: 100%;
        padding: 40px;
      }

      #docs .title {
        color: var(--gray);
        font-family: Inter, sans-serif;
        font-weight: 900;
        margin-bottom: 20px;
      }

      #docs article {
        font-family: monospace;
        margin: 40px;
      }
      #docs article h3 {
        font-family: monospace;
        font-size: 24px;
        color: var(--gray);
        text-align: center;
      }

      #docs article ul {
        list-style: none;
      }

      #docs article ul li {
        display: grid;
        grid-template-columns: 1fr 2fr 3fr;
        margin: 10px;
      }
      #docs article ul li .method {
        color: var(--green);
        text-align: right;
        grid-column: 1 / 2;
        margin-right: 20px;
      }
      #docs article ul li .url {
        color: var(--black);
        grid-column: 2 / 3;
        margin-right: 60px;
      }
      #docs article ul li .description {
        color: var(--gray);
        grid-column: 3 / 4;
      }
    </style>
  </head>

  <body>
    <section id=\\"hero\\">
      <header style=\\"flex: 1\\">
        <img src=\\"prisma.svg\\" alt=\\"Prisma logo\\" id=\\"prisma-logo\\" />
      </header>
      <div id=\\"hero-text\\">
        <h1 id=\\"title\\">SaaS Template</h1>
        <h3 id=\\"subtitle\\">
          Generated by
          <a href=\\"https://cloud.prisma.io\\" target=\\"_blank\\"
            >Prisma Data Platform</a
          >
        </h3>
      </div>
      <div style=\\"flex: 1\\"></div>
    </section>

    <section id=\\"docs\\">
      <h1 class=\\"title\\">API Endpoints</h1>
    </section>

    <script>
      const docs = [
        {
          model: 'User',
          endpoints: [
            {
              method: 'GET',
              url: '/api/user',
              description: 'Get all users',
            },
            {
              method: 'GET',
              url: '/api/user?id=:id',
              description: 'Get a single user',
            },
            {
              method: 'POST',
              url: '/api/userd',
              description: 'Create a single user',
            },
            {
              method: 'PUT',
              url: '/api/user?id=:id',
              description: 'Update a single user',
            },
            {
              method: 'DELETE',
              url: '/api/user?id=:id',
              description: 'Delete a single user',
            },
          ],
        },
        {
          model: 'Account',
          endpoints: [
            {
              method: 'GET',
              url: '/api/account',
              description: 'Get all accounts',
            },
            {
              method: 'GET',
              url: '/api/account?id=:id',
              description: 'Get a single account',
            },
            {
              method: 'POST',
              url: '/api/accountd',
              description: 'Create a single account',
            },
            {
              method: 'PUT',
              url: '/api/account?id=:id',
              description: 'Update a single account',
            },
            {
              method: 'DELETE',
              url: '/api/account?id=:id',
              description: 'Delete a single account',
            },
          ],
        },
        {
          model: 'Invite',
          endpoints: [
            {
              method: 'GET',
              url: '/api/invite',
              description: 'Get all invites',
            },
            {
              method: 'GET',
              url: '/api/invite?id=:id',
              description: 'Get a single invite',
            },
            {
              method: 'POST',
              url: '/api/invited',
              description: 'Create a single invite',
            },
            {
              method: 'PUT',
              url: '/api/invite?id=:id',
              description: 'Update a single invite',
            },
            {
              method: 'DELETE',
              url: '/api/invite?id=:id',
              description: 'Delete a single invite',
            },
          ],
        },
      ]

      // Rendering
      const container = document.getElementById('docs')

      for (const group of docs) {
        const article = document.createElement('article')

        const title = document.createElement('h3')
        title.innerText = group.model
        article.appendChild(title)

        const ul = document.createElement('ul')
        for (const endpoint of group.endpoints) {
          const li = document.createElement('li')
          li.classList.add('endpoint')

          const method = document.createElement('p')
          method.classList.add('method')
          method.innerText = endpoint.method
          li.appendChild(method)

          const url = document.createElement('p')
          url.classList.add('url')
          url.innerText = endpoint.url
          li.appendChild(url)

          const description = document.createElement('p')
          description.classList.add('description')
          description.innerText = endpoint.description
          li.appendChild(description)

          ul.appendChild(li)
        }
        article.appendChild(ul)

        container.appendChild(article)
      }
    </script>
  </body>
</html>",
    "path": "public/index.html",
  },
  "public/prisma.svg": Object {
    "content": "<svg width=\\"32\\" height=\\"40\\" viewBox=\\"0 0 32 40\\" fill=\\"none\\" xmlns=\\"http://www.w3.org/2000/svg\\">
<path fill-rule=\\"evenodd\\" clip-rule=\\"evenodd\\" d=\\"M0.28825 24.9389C-0.101619 25.5764 -0.0955847 26.3808 0.303803 27.0124L7.5326 38.4434C8.00176 39.1853 8.90609 39.5236 9.74539 39.2712L30.606 32.9977C31.7444 32.6554 32.3172 31.3823 31.8196 30.3003L18.4094 1.13932C17.7554 -0.282788 15.7839 -0.399522 14.9675 0.935524L0.28825 24.9389ZM18.1058 7.79741C17.8205 7.13653 16.854 7.23832 16.7124 7.94418L11.5428 33.7038C11.4338 34.247 11.9419 34.7108 12.4724 34.5524L26.9042 30.2411C27.3254 30.1153 27.5424 29.6497 27.368 29.2458L18.1058 7.79741Z\\" fill=\\"white\\"/>
</svg>",
    "path": "public/prisma.svg",
  },
  "sandbox.ts": Object {
    "content": "import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient()

const main = async () => {
  const accounts = await prisma.account.findMany({
    where: {
      isActive: true,
    },
  })

  console.log('Premium accounts: ', accounts)
}

main()
  .catch((e) => console.error('Error in Prisma Client query: ', e))
  .finally(async () => await prisma.$disconnect())",
    "path": "sandbox.ts",
  },
  "tsconfig.json": Object {
    "content": "{
  \\"compilerOptions\\": {
    \\"sourceMap\\": true,
    \\"outDir\\": \\"dist\\",
    \\"strict\\": true,
    \\"lib\\": [\\"esnext\\", \\"dom\\"],
    \\"esModuleInterop\\": true
  }
}",
    "path": "tsconfig.json",
  },
}
`;

exports[`Template classes have static data files urlShortener 1`] = `
Object {
  "README.md": Object {
    "content": "# URL Shortener

![Database diagram](https://raw.githubusercontent.com/prisma/prisma-schema-examples/main/urlShortener/diagram.png)

(Generated via https://github.com/notiz-dev/prisma-dbml-generator + https://dbdiagram.io)

### Setting this project up locally

Once you clone your repo, you'll want to set up this repo for local development. In order to start using Prisma locally, you need to make Prisma aware of your database. The most portable way to do this is to use environment variables via a \`.env\` file.

1. You'll see that your Prisma Schema file (at \`prisma/schema.prisma\`) is already configured to use an environment variable called \`DATABASE_URL\`. [Read more about environment variables in Prisma](https://www.prisma.io/docs/concepts/more/environment-variables)
2. You'll need a database to connect to. You may use the same one you used while setting this project up on the Prisma Data Platform, but we recommend setting up a local database and use that during development. If you're new to databases, we recommend [reading up](https://www.prisma.io/dataguide/) on them. This guide also has instructions on how to set up a local database.
3. Once you have a locally accessible database connection string, create a new file called \`.env\` in the \`prisma\` directory, and populate it with: \`DATABASE_URL=\\"<replace-me-with-your-connection-string>\\"\`. Prisma will automatically pick up the environment variable used in the schema and use its value to connect to your database.
4. Now you can run \`npm run init\` to set up your local database. This will create tables corresponding to models in your Prisma Schema and populate them with fake data for you to play around with.
   - [Read more about the Prisma Schema](https://www.prisma.io/docs/concepts/components/prisma-schema)
   - [Read more about database seeding](https://www.prisma.io/docs/guides/database/seed-database)

To learn more about Prisma, we recommend reading through our [Getting Started guide](https://www.prisma.io/docs/getting-started)",
    "path": "README.md",
  },
  "api/link.ts": Object {
    "content": "import { PrismaClient, Prisma } from '@prisma/client'
import { VercelRequest, VercelResponse } from '@vercel/node'

type VercelRequestQuery = {
  id?: string
}

export default async function (req: VercelRequest, res: VercelResponse) {
  try {
    const { id } = req.query as VercelRequestQuery
    const prisma = new PrismaClient()

    console.log(
      '[link] Incoming request:',
      JSON.stringify(
        {
          method: req.method,
          query: req.query,
          body: req.body,
        },
        null,
        2,
      ),
    )

    switch (req.method) {
      case 'GET':
        return res.json(
          await prisma.link.findMany({
            where: { id },
          }),
        )
      case 'POST':
        return res.json(
          await prisma.link.create({
            data: req.body as Prisma.LinkCreateInput,
          }),
        )
      case 'PUT':
        return res.json(
          await prisma.link.update({
            where: {
              id,
            },
            data: req.body as Prisma.LinkUpdateInput,
          }),
        )
      case 'DELETE':
        return res.json(
          await prisma.link.delete({
            where: { id },
          }),
        )
    }

    return res
      .status(400)
      .send({ message: \`Unexpected request method: \${req.method}\` })
  } catch (e: any) {
    console.error('[link] Error responding:', e)
    return res.status(500).json({ message: e?.message || e })
  }
}",
    "path": "api/link.ts",
  },
  "api/user.ts": Object {
    "content": "import { PrismaClient, Prisma } from '@prisma/client'
import { VercelRequest, VercelResponse } from '@vercel/node'

type VercelRequestQuery = {
  id?: string
}

export default async function (req: VercelRequest, res: VercelResponse) {
  try {
    const { id } = req.query as VercelRequestQuery
    const prisma = new PrismaClient()

    console.log(
      '[user] Incoming request:',
      JSON.stringify(
        {
          method: req.method,
          query: req.query,
          body: req.body,
        },
        null,
        2,
      ),
    )

    switch (req.method) {
      case 'GET':
        return res.json(
          await prisma.user.findMany({
            where: { id },
          }),
        )
      case 'POST':
        return res.json(
          await prisma.user.create({
            data: req.body as Prisma.UserCreateInput,
          }),
        )
      case 'PUT':
        return res.json(
          await prisma.user.update({
            where: {
              id,
            },
            data: req.body as Prisma.UserUpdateInput,
          }),
        )
      case 'DELETE':
        return res.json(
          await prisma.user.delete({
            where: { id },
          }),
        )
    }

    return res
      .status(400)
      .send({ message: \`Unexpected request method: \${req.method}\` })
  } catch (e: any) {
    console.error('[user] Error responding:', e)
    return res.status(500).json({ message: e?.message || e })
  }
}",
    "path": "api/user.ts",
  },
  "package.json": Object {
    "content": "{
  \\"name\\": \\"url-shortener\\",
  \\"license\\": \\"UNLICENSED\\",
  \\"devDependencies\\": {
    \\"@types/faker\\": \\"5.5.8\\",
    \\"@types/node\\": \\"16.9.6\\",
    \\"@vercel/node\\": \\"1.12.1\\",
    \\"faker\\": \\"5.5.3\\",
    \\"prisma\\": \\"3.0.1\\",
    \\"ts-node\\": \\"10.2.1\\",
    \\"typescript\\": \\"4.4.3\\"
  },
  \\"prisma\\": {
    \\"seed\\": \\"ts-node prisma/seed\\"
  },
  \\"scripts\\": {
    \\"init\\": \\"prisma db push && prisma db seed\\",
    \\"dev\\": \\"ts-node ./sandbox.ts\\"
  },
  \\"dependencies\\": {
    \\"@prisma/client\\": \\"3.0.1\\"
  },
  \\"engines\\": {
    \\"node\\": \\">=12.2.0\\"
  }
}",
    "path": "package.json",
  },
  "prisma/schema.prisma": Object {
    "content": "// Schema for a simple URL shortener
// This schema tracks short links by associating them to a user

datasource db {
  provider = \\"postgresql\\"
  url      = env(\\"DATABASE_URL\\")
}

generator client {
  provider = \\"prisma-client-js\\"
}

model Link {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  url       String
  shortUrl  String
  User      User?    @relation(fields: [userId], references: [id])
  userId    String?
}

model User {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  name      String?
  email     String
  links     Link[]
}",
    "path": "prisma/schema.prisma",
  },
  "prisma/seed.ts": Object {
    "content": "import { PrismaClient } from '@prisma/client'
import * as faker from 'faker'

const NUMBER_OF_USERS = 4
const MAX_NUMBER_OF_LINKS = 5

const data = Array.from({ length: NUMBER_OF_USERS }).map(() => ({
  email: faker.internet.email(),
  name: faker.name.firstName(),
  links: Array.from({
    length: faker.datatype.number({
      min: 0,
      max: MAX_NUMBER_OF_LINKS,
    }),
  }).map(() => ({
    url: faker.internet.url(),
    shortUrl: faker.internet.domainWord(),
  })),
}))

export async function seed() {
  const prisma = new PrismaClient()

  try {
    for (let entry of data) {
      await prisma.user.create({
        data: {
          name: entry.name,
          email: entry.email,
          links: {
            create: entry.links,
          },
        },
      })
    }
  } catch (e) {
    await prisma.$disconnect()
    throw e
  } finally {
    await prisma.$disconnect()
  }
}",
    "path": "prisma/seed.ts",
  },
  "public/index.html": Object {
    "content": "<html>
  <head>
    <title>URL Shortener Template</title>

    <link rel=\\"icon\\" type=\\"image/svg\\" href=\\"prisma.svg\\" />
    <style>
      @font-face {
        font-family: Inter;
        font-weight: 400;
        src: url('https://cdn.jsdelivr.net/npm/@fontsource/inter/files/inter-latin-400-normal.woff2')
            format('woff2'),
          url('https://cdn.jsdelivr.net/npm/@fontsource/inter/files/inter-latin-400-normal.woff')
            format('woff');
      }

      @font-face {
        font-family: Inter;
        font-weight: 900;
        src: url('https://cdn.jsdelivr.net/npm/@fontsource/inter/files/inter-latin-900-normal.woff2')
            format('woff2'),
          url('https://cdn.jsdelivr.net/npm/@fontsource/inter/files/inter-latin-900-normal.woff')
            format('woff');
      }
    </style>

    <style>
      :root {
        --prisma-blue: #1a202c;
        --white: #ffffff;
        --green: #34d399;
        --black: #000000;
        --gray: rgba(0, 0, 0, 0.75);
      }
    </style>

    <style>
      body {
        margin: 0;
        padding: 0;
        font-size: 16px;
      }
      * {
        box-sizing: border-box;
      }
      h1,
      h2,
      h3,
      h4,
      h5,
      h6,
      p {
        margin: 0;
      }

      #hero {
        background: var(--prisma-blue);
        height: 60%;
        color: var(--white);
        font-family: Inter, sans-serif;
        display: flex;
        flex-direction: column;
        align-items: center;
      }

      #prisma-logo {
        padding: 50px;
      }

      #hero-text {
        display: flex;
        flex-direction: column;
        align-items: center;
        flex: 1;
      }

      #title {
        font-size: 72px;
        font-weight: 900;
        line-height: 1;
      }

      #subtitle {
        font-size: 24px;
        font-weight: 400;
        margin: 20px;
      }
      #subtitle a {
        color: var(--white) !important;
      }

      #docs {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        margin: 0 auto;
        width: 100%;
        padding: 40px;
      }

      #docs .title {
        color: var(--gray);
        font-family: Inter, sans-serif;
        font-weight: 900;
        margin-bottom: 20px;
      }

      #docs article {
        font-family: monospace;
        margin: 40px;
      }
      #docs article h3 {
        font-family: monospace;
        font-size: 24px;
        color: var(--gray);
        text-align: center;
      }

      #docs article ul {
        list-style: none;
      }

      #docs article ul li {
        display: grid;
        grid-template-columns: 1fr 2fr 3fr;
        margin: 10px;
      }
      #docs article ul li .method {
        color: var(--green);
        text-align: right;
        grid-column: 1 / 2;
        margin-right: 20px;
      }
      #docs article ul li .url {
        color: var(--black);
        grid-column: 2 / 3;
        margin-right: 60px;
      }
      #docs article ul li .description {
        color: var(--gray);
        grid-column: 3 / 4;
      }
    </style>
  </head>

  <body>
    <section id=\\"hero\\">
      <header style=\\"flex: 1\\">
        <img src=\\"prisma.svg\\" alt=\\"Prisma logo\\" id=\\"prisma-logo\\" />
      </header>
      <div id=\\"hero-text\\">
        <h1 id=\\"title\\">URL Shortener Template</h1>
        <h3 id=\\"subtitle\\">
          Generated by
          <a href=\\"https://cloud.prisma.io\\" target=\\"_blank\\"
            >Prisma Data Platform</a
          >
        </h3>
      </div>
      <div style=\\"flex: 1\\"></div>
    </section>

    <section id=\\"docs\\">
      <h1 class=\\"title\\">API Endpoints</h1>
    </section>

    <script>
      const docs = [
        {
          model: 'User',
          endpoints: [
            {
              method: 'GET',
              url: '/api/user',
              description: 'Get all users',
            },
            {
              method: 'GET',
              url: '/api/user?id=:id',
              description: 'Get a single user',
            },
            {
              method: 'POST',
              url: '/api/userd',
              description: 'Create a single user',
            },
            {
              method: 'PUT',
              url: '/api/user?id=:id',
              description: 'Update a single user',
            },
            {
              method: 'DELETE',
              url: '/api/user?id=:id',
              description: 'Delete a single user',
            },
          ],
        },
        {
          model: 'Link',
          endpoints: [
            {
              method: 'GET',
              url: '/api/link',
              description: 'Get all links',
            },
            {
              method: 'GET',
              url: '/api/link?id=:id',
              description: 'Get a single link',
            },
            {
              method: 'POST',
              url: '/api/link',
              description: 'Create a single link',
            },
            {
              method: 'PUT',
              url: '/api/link?id=:id',
              description: 'Update a single link',
            },
            {
              method: 'DELETE',
              url: '/api/link?id=:id',
              description: 'Delete a single link',
            },
          ],
        },
      ]

      // Rendering
      const container = document.getElementById('docs')

      for (const group of docs) {
        const article = document.createElement('article')

        const title = document.createElement('h3')
        title.innerText = group.model
        article.appendChild(title)

        const ul = document.createElement('ul')
        for (const endpoint of group.endpoints) {
          const li = document.createElement('li')
          li.classList.add('endpoint')

          const method = document.createElement('p')
          method.classList.add('method')
          method.innerText = endpoint.method
          li.appendChild(method)

          const url = document.createElement('p')
          url.classList.add('url')
          url.innerText = endpoint.url
          li.appendChild(url)

          const description = document.createElement('p')
          description.classList.add('description')
          description.innerText = endpoint.description
          li.appendChild(description)

          ul.appendChild(li)
        }
        article.appendChild(ul)

        container.appendChild(article)
      }
    </script>
  </body>
</html>",
    "path": "public/index.html",
  },
  "public/prisma.svg": Object {
    "content": "<svg width=\\"32\\" height=\\"40\\" viewBox=\\"0 0 32 40\\" fill=\\"none\\" xmlns=\\"http://www.w3.org/2000/svg\\">
<path fill-rule=\\"evenodd\\" clip-rule=\\"evenodd\\" d=\\"M0.28825 24.9389C-0.101619 25.5764 -0.0955847 26.3808 0.303803 27.0124L7.5326 38.4434C8.00176 39.1853 8.90609 39.5236 9.74539 39.2712L30.606 32.9977C31.7444 32.6554 32.3172 31.3823 31.8196 30.3003L18.4094 1.13932C17.7554 -0.282788 15.7839 -0.399522 14.9675 0.935524L0.28825 24.9389ZM18.1058 7.79741C17.8205 7.13653 16.854 7.23832 16.7124 7.94418L11.5428 33.7038C11.4338 34.247 11.9419 34.7108 12.4724 34.5524L26.9042 30.2411C27.3254 30.1153 27.5424 29.6497 27.368 29.2458L18.1058 7.79741Z\\" fill=\\"white\\"/>
</svg>",
    "path": "public/prisma.svg",
  },
  "sandbox.ts": Object {
    "content": "import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient()

const main = async () => {
  const users = await prisma.user.findMany({
    where: {
      name: {
        startsWith: 'A',
      },
    },
  })

  console.log('Top users (alphabetical): ', users)
}

main()
  .catch((e) => console.error('Error in Prisma Client query: ', e))
  .finally(async () => await prisma.$disconnect())",
    "path": "sandbox.ts",
  },
  "tsconfig.json": Object {
    "content": "{
  \\"compilerOptions\\": {
    \\"sourceMap\\": true,
    \\"outDir\\": \\"dist\\",
    \\"strict\\": true,
    \\"lib\\": [\\"esnext\\", \\"dom\\"],
    \\"esModuleInterop\\": true
  }
}",
    "path": "tsconfig.json",
  },
}
`;

exports[`Template classes have static data metadata empty 1`] = `
Object {
  "displayName": "Empty",
  "githubUrl": "https://github.com/prisma/prisma-schema-examples/tree/main/empty",
  "name": "empty",
}
`;

exports[`Template classes have static data metadata musicStreamingService 1`] = `
Object {
  "displayName": "Music Streaming Service",
  "githubUrl": "https://github.com/prisma/prisma-schema-examples/tree/main/musicStreamingService",
  "name": "musicStreamingService",
}
`;

exports[`Template classes have static data metadata rentalsPlatform 1`] = `
Object {
  "displayName": "Rentals Platform",
  "githubUrl": "https://github.com/prisma/prisma-schema-examples/tree/main/rentalsPlatform",
  "name": "rentalsPlatform",
}
`;

exports[`Template classes have static data metadata saas 1`] = `
Object {
  "displayName": "Saas",
  "githubUrl": "https://github.com/prisma/prisma-schema-examples/tree/main/saas",
  "name": "saas",
}
`;

exports[`Template classes have static data metadata urlShortener 1`] = `
Object {
  "displayName": "Url Shortener",
  "githubUrl": "https://github.com/prisma/prisma-schema-examples/tree/main/urlShortener",
  "name": "urlShortener",
}
`;

exports[`templates can be instantiated with custom datasourceProvider empty 1`] = `
Empty {
  "artifacts": Object {
    "prisma/seed.js": Object {
      "content": "\\"use strict\\";

Object.defineProperty(exports, \\"__esModule\\", {
  value: true
});
exports.seed = seed;

var _studioPcw = require(\\"@prisma/studio-pcw\\");

const schema = \`PRISMA TEMPLATE: empty\`;
const schemaPath = \\"/tmp/schema.prisma\\";

async function seed() {
  const pcw = new _studioPcw.PCW(schema, schemaPath, {
    PRISMA_CLOUD_PROJECT_DATASOURCE_URL: process.env.PRISMA_CLOUD_PROJECT_DATASOURCE_URL
  }, {
    forcePrismaLibrary: true,
    resolve: {
      \\".prisma/client\\": require.resolve(\\".prisma/client\\")
    }
  });
  const {
    prisma: prisma
  } = await pcw.getPrismaClient();
}

(async () => await seed())()",
      "path": "prisma/seed.js",
    },
  },
  "files": Object {
    "README.md": Object {
      "content": "# Empty Prisma Project

An empty Prisma Schema with no models, perfect as a starting point for your own schema.",
      "path": "README.md",
    },
    "package.json": Object {
      "content": "{
  \\"name\\": \\"empty\\",
  \\"license\\": \\"UNLICENSED\\",
  \\"devDependencies\\": {
    \\"prisma\\": \\"2.30.3\\"
  },
  \\"dependencies\\": {
    \\"@prisma/client\\": \\"3.0.1\\"
  },
  \\"engines\\": {
    \\"node\\": \\">=10.0.0\\"
  }
}",
      "path": "package.json",
    },
    "prisma/schema.prisma": Object {
      "content": "// An empty Prisma Schema with no models, perfect as a starting point for your own schema.

datasource db {
  provider = \\"mysql\\"
  url      = env(\\"DATABASE_URL\\")
}

generator client {
  provider = \\"prisma-client-js\\"
}",
      "path": "prisma/schema.prisma",
    },
    "prisma/seed.ts": Object {
      "content": "import { PrismaClient } from \\"@prisma/client\\";

export async function seed() {
  const prisma = new PrismaClient();
}",
      "path": "prisma/seed.ts",
    },
    "public/index.html": Object {
      "content": "<html>
  <head>
    <title>Empty Template</title>

    <link rel=\\"icon\\" type=\\"image/svg\\" href=\\"prisma.svg\\" />
    <style>
      @font-face {
        font-family: Inter;
        font-weight: 400;
        src: url('https://cdn.jsdelivr.net/npm/@fontsource/inter/files/inter-latin-400-normal.woff2')
            format('woff2'),
          url('https://cdn.jsdelivr.net/npm/@fontsource/inter/files/inter-latin-400-normal.woff')
            format('woff');
      }

      @font-face {
        font-family: Inter;
        font-weight: 900;
        src: url('https://cdn.jsdelivr.net/npm/@fontsource/inter/files/inter-latin-900-normal.woff2')
            format('woff2'),
          url('https://cdn.jsdelivr.net/npm/@fontsource/inter/files/inter-latin-900-normal.woff')
            format('woff');
      }
    </style>

    <style>
      :root {
        --prisma-blue: #1a202c;
        --white: #ffffff;
        --green: #34d399;
        --black: #000000;
        --gray: rgba(0, 0, 0, 0.75);
      }
    </style>

    <style>
      body {
        margin: 0;
        padding: 0;
        font-size: 16px;
      }
      * {
        box-sizing: border-box;
      }
      h1,
      h2,
      h3,
      h4,
      h5,
      h6,
      p {
        margin: 0;
      }

      #hero {
        background: var(--prisma-blue);
        height: 60%;
        color: var(--white);
        font-family: Inter, sans-serif;
        display: flex;
        flex-direction: column;
        align-items: center;
      }

      #prisma-logo {
        padding: 50px;
      }

      #hero-text {
        display: flex;
        flex-direction: column;
        align-items: center;
        flex: 1;
      }

      #title {
        font-size: 72px;
        font-weight: 900;
        line-height: 1;
      }

      #subtitle {
        font-size: 24px;
        font-weight: 400;
        margin: 20px;
      }
      #subtitle a {
        color: var(--white) !important;
      }
    </style>
  </head>

  <body>
    <section id=\\"hero\\">
      <header style=\\"flex: 1\\">
        <img src=\\"prisma.svg\\" alt=\\"Prisma logo\\" id=\\"prisma-logo\\" />
      </header>
      <div id=\\"hero-text\\">
        <h1 id=\\"title\\">Empty Template</h1>
        <h3 id=\\"subtitle\\">
          Generated by
          <a href=\\"https://cloud.prisma.io\\" target=\\"_blank\\"
            >Prisma Data Platform</a
          >
        </h3>
      </div>
      <div style=\\"flex: 1\\"></div>
    </section>
  </body>
</html>",
      "path": "public/index.html",
    },
    "public/prisma.svg": Object {
      "content": "<svg width=\\"32\\" height=\\"40\\" viewBox=\\"0 0 32 40\\" fill=\\"none\\" xmlns=\\"http://www.w3.org/2000/svg\\">
<path fill-rule=\\"evenodd\\" clip-rule=\\"evenodd\\" d=\\"M0.28825 24.9389C-0.101619 25.5764 -0.0955847 26.3808 0.303803 27.0124L7.5326 38.4434C8.00176 39.1853 8.90609 39.5236 9.74539 39.2712L30.606 32.9977C31.7444 32.6554 32.3172 31.3823 31.8196 30.3003L18.4094 1.13932C17.7554 -0.282788 15.7839 -0.399522 14.9675 0.935524L0.28825 24.9389ZM18.1058 7.79741C17.8205 7.13653 16.854 7.23832 16.7124 7.94418L11.5428 33.7038C11.4338 34.247 11.9419 34.7108 12.4724 34.5524L26.9042 30.2411C27.3254 30.1153 27.5424 29.6497 27.368 29.2458L18.1058 7.79741Z\\" fill=\\"white\\"/>
</svg>",
      "path": "public/prisma.svg",
    },
  },
  "metadata": Object {
    "displayName": "Empty",
    "githubUrl": "https://github.com/prisma/prisma-schema-examples/tree/main/empty",
    "name": "empty",
  },
}
`;

exports[`templates can be instantiated with custom datasourceProvider musicStreamingService 1`] = `
MusicStreamingService {
  "artifacts": Object {
    "prisma/seed.js": Object {
      "content": "\\"use strict\\";

Object.defineProperty(exports, \\"__esModule\\", {
  value: true
});
exports.seed = seed;

var _studioPcw = require(\\"@prisma/studio-pcw\\");

var faker = _interopRequireWildcard(require(\\"faker\\"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \\"function\\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \\"object\\" && typeof obj !== \\"function\\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \\"default\\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const MAX_NUMBER_OF_SONGS_PER_ARTIST = 5;
const NUMBER_OF_ARTISTS = 5;
const NUMBER_OF_USERS = 10;
const userIds = Array.from({
  length: NUMBER_OF_USERS
}).map(() => faker.datatype.uuid());
const schema = \`PRISMA TEMPLATE: musicStreamingService\`;
const schemaPath = \\"/tmp/schema.prisma\\";

async function seed() {
  const pcw = new _studioPcw.PCW(schema, schemaPath, {
    PRISMA_CLOUD_PROJECT_DATASOURCE_URL: process.env.PRISMA_CLOUD_PROJECT_DATASOURCE_URL
  }, {
    forcePrismaLibrary: true,
    resolve: {
      \\".prisma/client\\": require.resolve(\\".prisma/client\\")
    }
  });
  const {
    prisma: prisma
  } = await pcw.getPrismaClient();

  try {
    // Create artists
    await prisma.artist.createMany({
      data: Array.from({
        length: NUMBER_OF_ARTISTS
      }).map(() => ({
        name: faker.name.firstName()
      }))
    });
    const artists = await prisma.artist.findMany(); // Create songs for each artist

    for (const artist of artists) {
      await prisma.album.create({
        data: {
          cover: faker.image.imageUrl(),
          name: faker.random.words(2),
          artists: {
            connect: {
              id: artist.id
            }
          },
          songs: {
            create: Array.from({
              length: faker.datatype.number({
                min: 2,
                max: MAX_NUMBER_OF_SONGS_PER_ARTIST
              })
            }).map(() => ({
              artistId: artist.id,
              fileUrl: faker.internet.url(),
              length: faker.datatype.float(),
              name: faker.name.firstName()
            }))
          }
        }
      });
    } // Create songs


    const songs = await prisma.song.findMany();

    for (const userId of userIds) {
      // Create users
      await prisma.user.create({
        data: {
          id: userId,
          email: faker.internet.email(),
          name: faker.name.firstName(),
          interactions: {
            create: Array.from({
              length: faker.datatype.number({
                min: 3,
                max: songs.length
              })
            }).map(() => ({
              playCount: faker.datatype.number({
                min: 1,
                max: 1000
              }),
              songId: songs[faker.datatype.number({
                min: 0,
                max: songs.length - 1
              })].id,
              // random boolean
              isLiked: Math.random() < 0.5
            }))
          }
        }
      }); // Create Playlists

      await prisma.playlist.create({
        data: {
          name: faker.random.words(2),
          user: {
            connect: {
              id: userId
            }
          },
          // each playlist will have a random list of songs
          songs: {
            connect: songs.slice(0, faker.datatype.number({
              min: 1,
              max: songs.length - 1
            })).map(({
              id
            }) => ({
              id
            }))
          }
        }
      });
    }
  } catch (e) {
    await prisma.$disconnect();
    throw e;
  } finally {
    await prisma.$disconnect();
  }
}

(async () => await seed())()",
      "path": "prisma/seed.js",
    },
  },
  "files": Object {
    "README.md": Object {
      "content": "# Music Streaming Service

![Database diagram](https://raw.githubusercontent.com/prisma/prisma-schema-examples/main/musicStreamingService/diagram.png)

(Generated via https://github.com/notiz-dev/prisma-dbml-generator + https://dbdiagram.io)

### Setting this project up locally

Once you clone your repo, you'll want to set up this repo for local development. In order to start using Prisma locally, you need to make Prisma aware of your database. The most portable way to do this is to use environment variables via a \`.env\` file.

1. You'll see that your Prisma Schema file (at \`prisma/schema.prisma\`) is already configured to use an environment variable called \`DATABASE_URL\`. [Read more about environment variables in Prisma](https://www.prisma.io/docs/concepts/more/environment-variables)
2. You'll need a database to connect to. You may use the same one you used while setting this project up on the Prisma Data Platform, but we recommend setting up a local database and use that during development. If you're new to databases, we recommend [reading up](https://www.prisma.io/dataguide/) on them. This guide also has instructions on how to set up a local database.
3. Once you have a locally accessible database connection string, create a new file called \`.env\` in the \`prisma\` directory, and populate it with: \`DATABASE_URL=\\"<replace-me-with-your-connection-string>\\"\`. Prisma will automatically pick up the environment variable used in the schema and use its value to connect to your database.
4. Now you can run \`npm run init\` to set up your local database. This will create tables corresponding to models in your Prisma Schema and populate them with fake data for you to play around with.
   - [Read more about the Prisma Schema](https://www.prisma.io/docs/concepts/components/prisma-schema)
   - [Read more about database seeding](https://www.prisma.io/docs/guides/database/seed-database)

To learn more about Prisma, we recommend reading through our [Getting Started guide](https://www.prisma.io/docs/getting-started)",
      "path": "README.md",
    },
    "api/album.ts": Object {
      "content": "import { PrismaClient, Prisma } from '@prisma/client'
import { VercelRequest, VercelResponse } from '@vercel/node'

type VercelRequestQuery = {
  id?: string
}

export default async function (req: VercelRequest, res: VercelResponse) {
  try {
    const { id } = req.query as VercelRequestQuery
    const prisma = new PrismaClient()

    console.log(
      '[album] Incoming request:',
      JSON.stringify(
        {
          method: req.method,
          query: req.query,
          body: req.body,
        },
        null,
        2,
      ),
    )

    switch (req.method) {
      case 'GET':
        return res.json(
          await prisma.album.findMany({
            where: { id },
          }),
        )
      case 'POST':
        return res.json(
          await prisma.album.create({
            data: req.body as Prisma.AlbumCreateInput,
          }),
        )
      case 'PUT':
        return res.json(
          await prisma.album.update({
            where: {
              id,
            },
            data: req.body as Prisma.AlbumUpdateInput,
          }),
        )
      case 'DELETE':
        return res.json(
          await prisma.album.delete({
            where: { id },
          }),
        )
    }

    return res
      .status(400)
      .send({ message: \`Unexpected request method: \${req.method}\` })
  } catch (e: any) {
    console.error('[album] Error responding:', e)
    return res.status(500).json({ message: e?.message || e })
  }
}",
      "path": "api/album.ts",
    },
    "api/artist.ts": Object {
      "content": "import { PrismaClient, Prisma } from '@prisma/client'
import { VercelRequest, VercelResponse } from '@vercel/node'

type VercelRequestQuery = {
  id?: string
}

export default async function (req: VercelRequest, res: VercelResponse) {
  try {
    const { id } = req.query as VercelRequestQuery
    const prisma = new PrismaClient()

    console.log(
      '[artist] Incoming request:',
      JSON.stringify(
        {
          method: req.method,
          query: req.query,
          body: req.body,
        },
        null,
        2,
      ),
    )

    switch (req.method) {
      case 'GET':
        return res.json(
          await prisma.artist.findMany({
            where: { id },
          }),
        )
      case 'POST':
        return res.json(
          await prisma.artist.create({
            data: req.body as Prisma.ArtistCreateInput,
          }),
        )
      case 'PUT':
        return res.json(
          await prisma.artist.update({
            where: {
              id,
            },
            data: req.body as Prisma.ArtistUpdateInput,
          }),
        )
      case 'DELETE':
        return res.json(
          await prisma.artist.delete({
            where: { id },
          }),
        )
    }

    return res
      .status(400)
      .send({ message: \`Unexpected request method: \${req.method}\` })
  } catch (e: any) {
    console.error('[artist] Error responding:', e)
    return res.status(500).json({ message: e?.message || e })
  }
}",
      "path": "api/artist.ts",
    },
    "api/interaction.ts": Object {
      "content": "import { PrismaClient, Prisma } from '@prisma/client'
import { VercelRequest, VercelResponse } from '@vercel/node'

type VercelRequestQuery = {
  id?: string
}

export default async function (req: VercelRequest, res: VercelResponse) {
  try {
    const { id } = req.query as VercelRequestQuery
    const prisma = new PrismaClient()

    console.log(
      '[interaction] Incoming request:',
      JSON.stringify(
        {
          method: req.method,
          query: req.query,
          body: req.body,
        },
        null,
        2,
      ),
    )

    switch (req.method) {
      case 'GET':
        return res.json(
          await prisma.interaction.findMany({
            where: { id },
          }),
        )
      case 'POST':
        return res.json(
          await prisma.interaction.create({
            data: req.body as Prisma.InteractionCreateInput,
          }),
        )
      case 'PUT':
        return res.json(
          await prisma.interaction.update({
            where: {
              id,
            },
            data: req.body as Prisma.InteractionUpdateInput,
          }),
        )
      case 'DELETE':
        return res.json(
          await prisma.interaction.delete({
            where: { id },
          }),
        )
    }

    return res
      .status(400)
      .send({ message: \`Unexpected request method: \${req.method}\` })
  } catch (e: any) {
    console.error('[interaction] Error responding:', e)
    return res.status(500).json({ message: e?.message || e })
  }
}",
      "path": "api/interaction.ts",
    },
    "api/playlist.ts": Object {
      "content": "import { PrismaClient, Prisma } from '@prisma/client'
import { VercelRequest, VercelResponse } from '@vercel/node'

type VercelRequestQuery = {
  id?: string
}

export default async function (req: VercelRequest, res: VercelResponse) {
  try {
    const { id } = req.query as VercelRequestQuery
    const prisma = new PrismaClient()

    console.log(
      '[playlist] Incoming request:',
      JSON.stringify(
        {
          method: req.method,
          query: req.query,
          body: req.body,
        },
        null,
        2,
      ),
    )

    switch (req.method) {
      case 'GET':
        return res.json(
          await prisma.playlist.findMany({
            where: { id },
          }),
        )
      case 'POST':
        return res.json(
          await prisma.playlist.create({
            data: req.body as Prisma.PlaylistCreateInput,
          }),
        )
      case 'PUT':
        return res.json(
          await prisma.playlist.update({
            where: {
              id,
            },
            data: req.body as Prisma.PlaylistUpdateInput,
          }),
        )
      case 'DELETE':
        return res.json(
          await prisma.playlist.delete({
            where: { id },
          }),
        )
    }

    return res
      .status(400)
      .send({ message: \`Unexpected request method: \${req.method}\` })
  } catch (e: any) {
    console.error('[playlist] Error responding:', e)
    return res.status(500).json({ message: e?.message || e })
  }
}",
      "path": "api/playlist.ts",
    },
    "api/song.ts": Object {
      "content": "import { PrismaClient, Prisma } from '@prisma/client'
import { VercelRequest, VercelResponse } from '@vercel/node'

type VercelRequestQuery = {
  id?: string
}

export default async function (req: VercelRequest, res: VercelResponse) {
  try {
    const { id } = req.query as VercelRequestQuery
    const prisma = new PrismaClient()

    console.log(
      '[song] Incoming request:',
      JSON.stringify(
        {
          method: req.method,
          query: req.query,
          body: req.body,
        },
        null,
        2,
      ),
    )

    switch (req.method) {
      case 'GET':
        return res.json(
          await prisma.song.findMany({
            where: { id },
          }),
        )
      case 'POST':
        return res.json(
          await prisma.song.create({
            data: req.body as Prisma.SongCreateInput,
          }),
        )
      case 'PUT':
        return res.json(
          await prisma.song.update({
            where: {
              id,
            },
            data: req.body as Prisma.SongUpdateInput,
          }),
        )
      case 'DELETE':
        return res.json(
          await prisma.song.delete({
            where: { id },
          }),
        )
    }

    return res
      .status(400)
      .send({ message: \`Unexpected request method: \${req.method}\` })
  } catch (e: any) {
    console.error('[song] Error responding:', e)
    return res.status(500).json({ message: e?.message || e })
  }
}",
      "path": "api/song.ts",
    },
    "api/user.ts": Object {
      "content": "import { PrismaClient, Prisma } from '@prisma/client'
import { VercelRequest, VercelResponse } from '@vercel/node'

type VercelRequestQuery = {
  id?: string
}

export default async function (req: VercelRequest, res: VercelResponse) {
  try {
    const { id } = req.query as VercelRequestQuery
    const prisma = new PrismaClient()

    console.log(
      '[user] Incoming request:',
      JSON.stringify(
        {
          method: req.method,
          query: req.query,
          body: req.body,
        },
        null,
        2,
      ),
    )

    switch (req.method) {
      case 'GET':
        return res.json(
          await prisma.user.findMany({
            where: { id },
          }),
        )
      case 'POST':
        return res.json(
          await prisma.user.create({
            data: req.body as Prisma.UserCreateInput,
          }),
        )
      case 'PUT':
        return res.json(
          await prisma.user.update({
            where: {
              id,
            },
            data: req.body as Prisma.UserUpdateInput,
          }),
        )
      case 'DELETE':
        return res.json(
          await prisma.user.delete({
            where: { id },
          }),
        )
    }

    return res
      .status(400)
      .send({ message: \`Unexpected request method: \${req.method}\` })
  } catch (e: any) {
    console.error('[user] Error responding:', e)
    return res.status(500).json({ message: e?.message || e })
  }
}",
      "path": "api/user.ts",
    },
    "package.json": Object {
      "content": "{
  \\"name\\": \\"music-streaming-service\\",
  \\"license\\": \\"UNLICENSED\\",
  \\"devDependencies\\": {
    \\"@types/faker\\": \\"5.5.8\\",
    \\"@types/node\\": \\"16.9.6\\",
    \\"@vercel/node\\": \\"1.12.1\\",
    \\"faker\\": \\"5.5.3\\",
    \\"prisma\\": \\"3.0.1\\",
    \\"ts-node\\": \\"10.2.1\\",
    \\"typescript\\": \\"4.4.3\\"
  },
  \\"prisma\\": {
    \\"seed\\": \\"ts-node ./prisma/seed.ts\\"
  },
  \\"scripts\\": {
    \\"init\\": \\"prisma db push && prisma db seed\\",
    \\"dev\\": \\"ts-node ./sandbox.ts\\"
  },
  \\"dependencies\\": {
    \\"@prisma/client\\": \\"3.0.1\\"
  },
  \\"engines\\": {
    \\"node\\": \\">=12.2.0\\"
  }
}",
      "path": "package.json",
    },
    "prisma/schema.prisma": Object {
      "content": "// Schema for a fictional music streaming service
// This service contains songs, albums, artists & playlists, and tracks user interactions with each of them

datasource db {
  provider = \\"mysql\\"
  url      = env(\\"DATABASE_URL\\")
}

generator client {
  provider = \\"prisma-client-js\\"
}

model User {
  id           String        @id @default(uuid())
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt
  name         String
  email        String        @unique
  interactions Interaction[]
  playlists    Playlist[]
}

model Interaction {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  songId    String?
  userId    String?
  isLiked   Boolean  @default(false)
  playCount Int
  song      Song?    @relation(fields: [songId], references: [id])
  user      User?    @relation(fields: [userId], references: [id])
}

model Song {
  id           String        @id @default(uuid())
  interactions Interaction[]
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt
  name         String
  album        Album?        @relation(fields: [albumId], references: [id])
  albumId      String?
  artist       Artist        @relation(fields: [artistId], references: [id])
  artistId     String
  length       Float
  track        Int?
  lyrics       String?
  playlist     Playlist[]
  fileUrl      String
}

model Artist {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  name      String
  albums    Album[]
  songs     Song[]
}

model Album {
  id        String   @id @default(uuid())
  songs     Song[]
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  artists   Artist[]
  name      String
  cover     String
}

model Playlist {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  user      User?    @relation(fields: [userId], references: [id])
  userId    String?
  songs     Song[]
  name      String
}",
      "path": "prisma/schema.prisma",
    },
    "prisma/seed.ts": Object {
      "content": "import { PrismaClient } from '@prisma/client'
import * as faker from 'faker'

const MAX_NUMBER_OF_SONGS_PER_ARTIST = 5
const NUMBER_OF_ARTISTS = 5
const NUMBER_OF_USERS = 10

const userIds = Array.from({
  length: NUMBER_OF_USERS,
}).map(() => faker.datatype.uuid())

export async function seed() {
  const prisma = new PrismaClient()

  try {
    // Create artists
    await prisma.artist.createMany({
      data: Array.from({ length: NUMBER_OF_ARTISTS }).map(() => ({
        name: faker.name.firstName(),
      })),
    })

    const artists = await prisma.artist.findMany()

    // Create songs for each artist
    for (const artist of artists) {
      await prisma.album.create({
        data: {
          cover: faker.image.imageUrl(),
          name: faker.random.words(2),
          artists: {
            connect: {
              id: artist.id,
            },
          },
          songs: {
            create: Array.from({
              length: faker.datatype.number({
                min: 2,
                max: MAX_NUMBER_OF_SONGS_PER_ARTIST,
              }),
            }).map(() => ({
              artistId: artist.id,
              fileUrl: faker.internet.url(),
              length: faker.datatype.float(),
              name: faker.name.firstName(),
            })),
          },
        },
      })
    }

    // Create songs
    const songs = await prisma.song.findMany()

    for (const userId of userIds) {
      // Create users
      await prisma.user.create({
        data: {
          id: userId,
          email: faker.internet.email(),
          name: faker.name.firstName(),
          interactions: {
            create: Array.from({
              length: faker.datatype.number({
                min: 3,
                max: songs.length,
              }),
            }).map(() => ({
              playCount: faker.datatype.number({ min: 1, max: 1000 }),
              songId:
                songs[faker.datatype.number({ min: 0, max: songs.length - 1 })]
                  .id,
              // random boolean
              isLiked: Math.random() < 0.5,
            })),
          },
        },
      })

      // Create Playlists
      await prisma.playlist.create({
        data: {
          name: faker.random.words(2),
          user: {
            connect: {
              id: userId,
            },
          },
          // each playlist will have a random list of songs
          songs: {
            connect: songs
              .slice(
                0,
                faker.datatype.number({ min: 1, max: songs.length - 1 }),
              )
              .map(({ id }) => ({ id })),
          },
        },
      })
    }
  } catch (e) {
    await prisma.$disconnect()
    throw e
  } finally {
    await prisma.$disconnect()
  }
}",
      "path": "prisma/seed.ts",
    },
    "public/index.html": Object {
      "content": "<html>
  <head>
    <title>Music Streaming Service Template</title>

    <link rel=\\"icon\\" type=\\"image/svg\\" href=\\"prisma.svg\\" />
    <style>
      @font-face {
        font-family: Inter;
        font-weight: 400;
        src: url('https://cdn.jsdelivr.net/npm/@fontsource/inter/files/inter-latin-400-normal.woff2')
            format('woff2'),
          url('https://cdn.jsdelivr.net/npm/@fontsource/inter/files/inter-latin-400-normal.woff')
            format('woff');
      }

      @font-face {
        font-family: Inter;
        font-weight: 900;
        src: url('https://cdn.jsdelivr.net/npm/@fontsource/inter/files/inter-latin-900-normal.woff2')
            format('woff2'),
          url('https://cdn.jsdelivr.net/npm/@fontsource/inter/files/inter-latin-900-normal.woff')
            format('woff');
      }
    </style>

    <style>
      :root {
        --prisma-blue: #1a202c;
        --white: #ffffff;
        --green: #34d399;
        --black: #000000;
        --gray: rgba(0, 0, 0, 0.75);
      }
    </style>

    <style>
      body {
        margin: 0;
        padding: 0;
        font-size: 16px;
      }
      * {
        box-sizing: border-box;
      }
      h1,
      h2,
      h3,
      h4,
      h5,
      h6,
      p {
        margin: 0;
      }

      #hero {
        background: var(--prisma-blue);
        height: 60%;
        color: var(--white);
        font-family: Inter, sans-serif;
        display: flex;
        flex-direction: column;
        align-items: center;
      }

      #prisma-logo {
        padding: 50px;
      }

      #hero-text {
        display: flex;
        flex-direction: column;
        align-items: center;
        flex: 1;
      }

      #title {
        font-size: 72px;
        font-weight: 900;
        line-height: 1;
      }

      #subtitle {
        font-size: 24px;
        font-weight: 400;
        margin: 20px;
      }
      #subtitle a {
        color: var(--white) !important;
      }

      #docs {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        margin: 0 auto;
        width: 100%;
        padding: 40px;
      }

      #docs .title {
        color: var(--gray);
        font-family: Inter, sans-serif;
        font-weight: 900;
        margin-bottom: 20px;
      }

      #docs article {
        font-family: monospace;
        margin: 40px;
      }
      #docs article h3 {
        font-family: monospace;
        font-size: 24px;
        color: var(--gray);
        text-align: center;
      }

      #docs article ul {
        list-style: none;
      }

      #docs article ul li {
        display: grid;
        grid-template-columns: 1fr 2fr 3fr;
        margin: 10px;
      }
      #docs article ul li .method {
        color: var(--green);
        text-align: right;
        grid-column: 1 / 2;
        margin-right: 20px;
      }
      #docs article ul li .url {
        color: var(--black);
        grid-column: 2 / 3;
        margin-right: 60px;
      }
      #docs article ul li .description {
        color: var(--gray);
        grid-column: 3 / 4;
      }
    </style>
  </head>

  <body>
    <section id=\\"hero\\">
      <header style=\\"flex: 1\\">
        <img src=\\"prisma.svg\\" alt=\\"Prisma logo\\" id=\\"prisma-logo\\" />
      </header>
      <div id=\\"hero-text\\">
        <h1 id=\\"title\\">Music Streaming Service Template</h1>
        <h3 id=\\"subtitle\\">
          Generated by
          <a href=\\"https://cloud.prisma.io\\" target=\\"_blank\\"
            >Prisma Data Platform</a
          >
        </h3>
      </div>
      <div style=\\"flex: 1\\"></div>
    </section>

    <section id=\\"docs\\">
      <h1 class=\\"title\\">API Endpoints</h1>
    </section>

    <script>
      const docs = [
        {
          model: 'User',
          endpoints: [
            {
              method: 'GET',
              url: '/api/user',
              description: 'Get all users',
            },
            {
              method: 'GET',
              url: '/api/user?id=:id',
              description: 'Get a single user',
            },
            {
              method: 'POST',
              url: '/api/userd',
              description: 'Create a single user',
            },
            {
              method: 'PUT',
              url: '/api/user?id=:id',
              description: 'Update a single user',
            },
            {
              method: 'DELETE',
              url: '/api/user?id=:id',
              description: 'Delete a single user',
            },
          ],
        },
        {
          model: 'Interaction',
          endpoints: [
            {
              method: 'GET',
              url: '/api/interaction',
              description: 'Get all interactions',
            },
            {
              method: 'GET',
              url: '/api/interaction?id=:id',
              description: 'Get a single interaction',
            },
            {
              method: 'POST',
              url: '/api/interaction',
              description: 'Create a single interaction',
            },
            {
              method: 'PUT',
              url: '/api/interaction?id=:id',
              description: 'Update a single interaction',
            },
            {
              method: 'DELETE',
              url: '/api/interaction?id=:id',
              description: 'Delete a single interaction',
            },
          ],
        },
        {
          model: 'Song',
          endpoints: [
            {
              method: 'GET',
              url: '/api/song',
              description: 'Get all songs',
            },
            {
              method: 'GET',
              url: '/api/song?id=:id',
              description: 'Get a single song',
            },
            {
              method: 'POST',
              url: '/api/song',
              description: 'Create a single song',
            },
            {
              method: 'PUT',
              url: '/api/song?id=:id',
              description: 'Update a single song',
            },
            {
              method: 'DELETE',
              url: '/api/song?id=:id',
              description: 'Delete a single song',
            },
          ],
        },
        {
          model: 'Artist',
          endpoints: [
            {
              method: 'GET',
              url: '/api/artist',
              description: 'Get all artists',
            },
            {
              method: 'GET',
              url: '/api/artist?id=:id',
              description: 'Get a single artist',
            },
            {
              method: 'POST',
              url: '/api/artist',
              description: 'Create a single artist',
            },
            {
              method: 'PUT',
              url: '/api/artist?id=:id',
              description: 'Update a single artist',
            },
            {
              method: 'DELETE',
              url: '/api/artist?id=:id',
              description: 'Delete a single artist',
            },
          ],
        },
        {
          model: 'Album',
          endpoints: [
            {
              method: 'GET',
              url: '/api/album',
              description: 'Get all albums',
            },
            {
              method: 'GET',
              url: '/api/album?id=:id',
              description: 'Get a single album',
            },
            {
              method: 'POST',
              url: '/api/album',
              description: 'Create a single album',
            },
            {
              method: 'PUT',
              url: '/api/album?id=:id',
              description: 'Update a single album',
            },
            {
              method: 'DELETE',
              url: '/api/album?id=:id',
              description: 'Delete a single album',
            },
          ],
        },
        {
          model: 'Playlist',
          endpoints: [
            {
              method: 'GET',
              url: '/api/playlist',
              description: 'Get all playlists',
            },
            {
              method: 'GET',
              url: '/api/playlist?id=:id',
              description: 'Get a single playlist',
            },
            {
              method: 'POST',
              url: '/api/playlist',
              description: 'Create a single playlist',
            },
            {
              method: 'PUT',
              url: '/api/playlist?id=:id',
              description: 'Update a single playlist',
            },
            {
              method: 'DELETE',
              url: '/api/playlist?id=:id',
              description: 'Delete a single playlist',
            },
          ],
        },
      ]

      // Rendering
      const container = document.getElementById('docs')

      for (const group of docs) {
        const article = document.createElement('article')

        const title = document.createElement('h3')
        title.innerText = group.model
        article.appendChild(title)

        const ul = document.createElement('ul')
        for (const endpoint of group.endpoints) {
          const li = document.createElement('li')
          li.classList.add('endpoint')

          const method = document.createElement('p')
          method.classList.add('method')
          method.innerText = endpoint.method
          li.appendChild(method)

          const url = document.createElement('p')
          url.classList.add('url')
          url.innerText = endpoint.url
          li.appendChild(url)

          const description = document.createElement('p')
          description.classList.add('description')
          description.innerText = endpoint.description
          li.appendChild(description)

          ul.appendChild(li)
        }
        article.appendChild(ul)

        container.appendChild(article)
      }
    </script>
  </body>
</html>",
      "path": "public/index.html",
    },
    "public/prisma.svg": Object {
      "content": "<svg width=\\"32\\" height=\\"40\\" viewBox=\\"0 0 32 40\\" fill=\\"none\\" xmlns=\\"http://www.w3.org/2000/svg\\">
<path fill-rule=\\"evenodd\\" clip-rule=\\"evenodd\\" d=\\"M0.28825 24.9389C-0.101619 25.5764 -0.0955847 26.3808 0.303803 27.0124L7.5326 38.4434C8.00176 39.1853 8.90609 39.5236 9.74539 39.2712L30.606 32.9977C31.7444 32.6554 32.3172 31.3823 31.8196 30.3003L18.4094 1.13932C17.7554 -0.282788 15.7839 -0.399522 14.9675 0.935524L0.28825 24.9389ZM18.1058 7.79741C17.8205 7.13653 16.854 7.23832 16.7124 7.94418L11.5428 33.7038C11.4338 34.247 11.9419 34.7108 12.4724 34.5524L26.9042 30.2411C27.3254 30.1153 27.5424 29.6497 27.368 29.2458L18.1058 7.79741Z\\" fill=\\"white\\"/>
</svg>",
      "path": "public/prisma.svg",
    },
    "sandbox.ts": Object {
      "content": "import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient()

const main = async () => {
  const albums = await prisma.album.findMany({
    where: {
      name: {
        contains: ' '
      }
    }
  })

  console.log('Albums that have more than 1 word: ', albums)
}

main()
  .catch((e) => console.error('Error in Prisma Client query: ', e))
  .finally(async () => await prisma.$disconnect())",
      "path": "sandbox.ts",
    },
    "tsconfig.json": Object {
      "content": "{
  \\"compilerOptions\\": {
    \\"sourceMap\\": true,
    \\"outDir\\": \\"dist\\",
    \\"strict\\": true,
    \\"lib\\": [\\"esnext\\", \\"dom\\"],
    \\"esModuleInterop\\": true
  }
}",
      "path": "tsconfig.json",
    },
  },
  "metadata": Object {
    "displayName": "Music Streaming Service",
    "githubUrl": "https://github.com/prisma/prisma-schema-examples/tree/main/musicStreamingService",
    "name": "musicStreamingService",
  },
}
`;

exports[`templates can be instantiated with custom datasourceProvider rentalsPlatform 1`] = `
RentalsPlatform {
  "artifacts": Object {
    "prisma/seed.js": Object {
      "content": "\\"use strict\\";

Object.defineProperty(exports, \\"__esModule\\", {
  value: true
});
exports.seed = seed;

var _studioPcw = require(\\"@prisma/studio-pcw\\");

var faker = _interopRequireWildcard(require(\\"faker\\"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \\"function\\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \\"object\\" && typeof obj !== \\"function\\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \\"default\\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const NUMBER_OF_USERS = 10;
const NUMBER_OF_ROOMS = 20;
const roomIds = Array.from({
  length: NUMBER_OF_ROOMS
}).map(() => faker.datatype.uuid());
const rooms = Array.from({
  length: NUMBER_OF_ROOMS
}).map((_, i) => ({
  id: roomIds[i],
  price: faker.datatype.number({
    min: 50,
    max: 600
  }),
  // random address - example: b-365
  address: \`\${faker.address.streetPrefix()}-\${faker.datatype.number({
    min: 300,
    max: 1
  })}\`,
  totalOccupancy: faker.datatype.number({
    min: 1,
    max: 5
  }),
  totalBedrooms: faker.datatype.number({
    min: 1,
    max: 5
  }),
  totalBathrooms: faker.datatype.number({
    min: 1,
    max: 5
  }),
  summary: faker.lorem.paragraph(),
  media: Array.from({
    length: faker.datatype.number({
      min: 1,
      max: 5
    })
  }).map(() => ({
    fileName: faker.image.imageUrl()
  }))
}));
const users = Array.from({
  length: NUMBER_OF_USERS
}).map(() => ({
  email: faker.internet.email(),
  name: faker.name.firstName(),
  reviews: Array.from({
    length: faker.datatype.number({
      max: 1,
      min: 4
    })
  }).map(() => ({
    comment: faker.lorem.paragraph(),
    rating: faker.datatype.number({
      max: 1,
      min: 5
    })
  })),
  // create random reservations per user
  reservations: Array.from({
    length: faker.datatype.number({
      min: 1,
      max: 4
    })
  }).map(() => {
    const startDate = faker.date.past();
    const endDate = faker.date.future();
    const price = faker.datatype.number({
      min: 50,
      max: 600
    });
    return {
      startDate,
      endDate,
      price,
      total: Math.ceil(Math.abs(+endDate - +startDate) / (1000 * 60 * 60 * 24)) * price,
      // difference between dates * price
      room: {
        connect: {
          id: roomIds[faker.datatype.number({
            min: 0,
            max: NUMBER_OF_ROOMS - 1
          })]
        }
      }
    };
  })
}));
const schema = \`PRISMA TEMPLATE: rentalsPlatform\`;
const schemaPath = \\"/tmp/schema.prisma\\";

async function seed() {
  const pcw = new _studioPcw.PCW(schema, schemaPath, {
    PRISMA_CLOUD_PROJECT_DATASOURCE_URL: process.env.PRISMA_CLOUD_PROJECT_DATASOURCE_URL
  }, {
    forcePrismaLibrary: true,
    resolve: {
      \\".prisma/client\\": require.resolve(\\".prisma/client\\")
    }
  });
  const {
    prisma: prisma
  } = await pcw.getPrismaClient();

  try {
    for (let room of rooms) {
      await prisma.room.create({
        data: {
          id: room.id,
          address: room.address,
          price: room.price,
          summary: room.summary,
          media: {
            create: room.media
          }
        }
      });
    }

    for (let user of users) {
      await prisma.user.create({
        data: {
          email: user.email,
          name: user.name,
          reservations: {
            create: user.reservations
          },
          reviews: {
            create: user.reviews
          }
        }
      });
    }
  } catch (e) {
    await prisma.$disconnect();
    throw e;
  } finally {
    await prisma.$disconnect();
  }
}

(async () => await seed())()",
      "path": "prisma/seed.js",
    },
  },
  "files": Object {
    "README.md": Object {
      "content": "# Rentals Platform

![Database Diagram](https://github.com/prisma/prisma-schema-examples/blob/main/rentalsPlatform/diagram.png?raw=true)

(Generated via https://github.com/notiz-dev/prisma-dbml-generator + https://dbdiagram.io)

### Setting this project up locally

Once you clone your repo, you'll want to set up this repo for local development. In order to start using Prisma locally, you need to make Prisma aware of your database. The most portable way to do this is to use environment variables via a \`.env\` file.

1. You'll see that your Prisma Schema file (at \`prisma/schema.prisma\`) is already configured to use an environment variable called \`DATABASE_URL\`. [Read more about environment variables in Prisma](https://www.prisma.io/docs/concepts/more/environment-variables)
2. You'll need a database to connect to. You may use the same one you used while setting this project up on the Prisma Data Platform, but we recommend setting up a local database and use that during development. If you're new to databases, we recommend [reading up](https://www.prisma.io/dataguide/) on them. This guide also has instructions on how to set up a local database.
3. Once you have a locally accessible database connection string, create a new file called \`.env\` in the \`prisma\` directory, and populate it with: \`DATABASE_URL=\\"<replace-me-with-your-connection-string>\\"\`. Prisma will automatically pick up the environment variable used in the schema and use its value to connect to your database.
4. Now you can run \`npm run init\` to set up your local database. This will create tables corresponding to models in your Prisma Schema and populate them with fake data for you to play around with.
   - [Read more about the Prisma Schema](https://www.prisma.io/docs/concepts/components/prisma-schema)
   - [Read more about database seeding](https://www.prisma.io/docs/guides/database/seed-database)

To learn more about Prisma, we recommend reading through our [Getting Started guide](https://www.prisma.io/docs/getting-started)",
      "path": "README.md",
    },
    "api/media.ts": Object {
      "content": "import { PrismaClient, Prisma } from '@prisma/client'
import { VercelRequest, VercelResponse } from '@vercel/node'

type VercelRequestQuery = {
  id?: string
}

export default async function (req: VercelRequest, res: VercelResponse) {
  try {
    const { id } = req.query as VercelRequestQuery
    const prisma = new PrismaClient()

    console.log(
      '[media] Incoming request:',
      JSON.stringify(
        {
          method: req.method,
          query: req.query,
          body: req.body,
        },
        null,
        2,
      ),
    )

    switch (req.method) {
      case 'GET':
        return res.json(
          await prisma.media.findMany({
            where: { id },
          }),
        )
      case 'POST':
        return res.json(
          await prisma.media.create({
            data: req.body as Prisma.MediaCreateInput,
          }),
        )
      case 'PUT':
        return res.json(
          await prisma.media.update({
            where: {
              id,
            },
            data: req.body as Prisma.MediaUpdateInput,
          }),
        )
      case 'DELETE':
        return res.json(
          await prisma.media.delete({
            where: { id },
          }),
        )
    }

    return res
      .status(400)
      .send({ message: \`Unexpected request method: \${req.method}\` })
  } catch (e: any) {
    console.error('[media] Error responding:', e)
    return res.status(500).json({ message: e?.message || e })
  }
}",
      "path": "api/media.ts",
    },
    "api/reservation.ts": Object {
      "content": "import { PrismaClient, Prisma } from '@prisma/client'
import { VercelRequest, VercelResponse } from '@vercel/node'

type VercelRequestQuery = {
  id?: string
}

export default async function (req: VercelRequest, res: VercelResponse) {
  try {
    const { id } = req.query as VercelRequestQuery
    const prisma = new PrismaClient()

    console.log(
      '[reservation] Incoming request:',
      JSON.stringify(
        {
          method: req.method,
          query: req.query,
          body: req.body,
        },
        null,
        2,
      ),
    )

    switch (req.method) {
      case 'GET':
        return res.json(
          await prisma.reservation.findMany({
            where: { id },
          }),
        )
      case 'POST':
        return res.json(
          await prisma.reservation.create({
            data: req.body as Prisma.ReservationCreateInput,
          }),
        )
      case 'PUT':
        return res.json(
          await prisma.reservation.update({
            where: {
              id,
            },
            data: req.body as Prisma.ReservationUpdateInput,
          }),
        )
      case 'DELETE':
        return res.json(
          await prisma.reservation.delete({
            where: { id },
          }),
        )
    }

    return res
      .status(400)
      .send({ message: \`Unexpected request method: \${req.method}\` })
  } catch (e: any) {
    console.error('[reservation] Error responding:', e)
    return res.status(500).json({ message: e?.message || e })
  }
}",
      "path": "api/reservation.ts",
    },
    "api/review.ts": Object {
      "content": "import { PrismaClient, Prisma } from '@prisma/client'
import { VercelRequest, VercelResponse } from '@vercel/node'

type VercelRequestQuery = {
  id?: string
}

export default async function (req: VercelRequest, res: VercelResponse) {
  try {
    const { id } = req.query as VercelRequestQuery
    const prisma = new PrismaClient()

    console.log(
      '[review] Incoming request:',
      JSON.stringify(
        {
          method: req.method,
          query: req.query,
          body: req.body,
        },
        null,
        2,
      ),
    )

    switch (req.method) {
      case 'GET':
        return res.json(
          await prisma.review.findMany({
            where: { id },
          }),
        )
      case 'POST':
        return res.json(
          await prisma.review.create({
            data: req.body as Prisma.ReviewCreateInput,
          }),
        )
      case 'PUT':
        return res.json(
          await prisma.review.update({
            where: {
              id,
            },
            data: req.body as Prisma.ReviewUpdateInput,
          }),
        )
      case 'DELETE':
        return res.json(
          await prisma.review.delete({
            where: { id },
          }),
        )
    }

    return res
      .status(400)
      .send({ message: \`Unexpected request method: \${req.method}\` })
  } catch (e: any) {
    console.error('[review] Error responding:', e)
    return res.status(500).json({ message: e?.message || e })
  }
}",
      "path": "api/review.ts",
    },
    "api/room.ts": Object {
      "content": "import { PrismaClient, Prisma } from '@prisma/client'
import { VercelRequest, VercelResponse } from '@vercel/node'

type VercelRequestQuery = {
  id?: string
}

export default async function (req: VercelRequest, res: VercelResponse) {
  try {
    const { id } = req.query as VercelRequestQuery
    const prisma = new PrismaClient()

    console.log(
      '[room] Incoming request:',
      JSON.stringify(
        {
          method: req.method,
          query: req.query,
          body: req.body,
        },
        null,
        2,
      ),
    )

    switch (req.method) {
      case 'GET':
        return res.json(
          await prisma.room.findMany({
            where: { id },
          }),
        )
      case 'POST':
        return res.json(
          await prisma.room.create({
            data: req.body as Prisma.RoomCreateInput,
          }),
        )
      case 'PUT':
        return res.json(
          await prisma.room.update({
            where: {
              id,
            },
            data: req.body as Prisma.RoomUpdateInput,
          }),
        )
      case 'DELETE':
        return res.json(
          await prisma.room.delete({
            where: { id },
          }),
        )
    }

    return res
      .status(400)
      .send({ message: \`Unexpected request method: \${req.method}\` })
  } catch (e: any) {
    console.error('[room] Error responding:', e)
    return res.status(500).json({ message: e?.message || e })
  }
}",
      "path": "api/room.ts",
    },
    "api/user.ts": Object {
      "content": "import { PrismaClient, Prisma } from '@prisma/client'
import { VercelRequest, VercelResponse } from '@vercel/node'

type VercelRequestQuery = {
  id?: string
}

export default async function (req: VercelRequest, res: VercelResponse) {
  try {
    const { id } = req.query as VercelRequestQuery
    const prisma = new PrismaClient()

    console.log(
      '[user] Incoming request:',
      JSON.stringify(
        {
          method: req.method,
          query: req.query,
          body: req.body,
        },
        null,
        2,
      ),
    )

    switch (req.method) {
      case 'GET':
        return res.json(
          await prisma.user.findMany({
            where: { id },
          }),
        )
      case 'POST':
        return res.json(
          await prisma.user.create({
            data: req.body as Prisma.UserCreateInput,
          }),
        )
      case 'PUT':
        return res.json(
          await prisma.user.update({
            where: {
              id,
            },
            data: req.body as Prisma.UserUpdateInput,
          }),
        )
      case 'DELETE':
        return res.json(
          await prisma.user.delete({
            where: { id },
          }),
        )
    }

    return res
      .status(400)
      .send({ message: \`Unexpected request method: \${req.method}\` })
  } catch (e: any) {
    console.error('[user] Error responding:', e)
    return res.status(500).json({ message: e?.message || e })
  }
}",
      "path": "api/user.ts",
    },
    "package.json": Object {
      "content": "{
  \\"name\\": \\"rentals-platform\\",
  \\"license\\": \\"UNLICENSED\\",
  \\"devDependencies\\": {
    \\"@types/faker\\": \\"5.5.8\\",
    \\"@types/node\\": \\"16.9.6\\",
    \\"@vercel/node\\": \\"1.12.1\\",
    \\"faker\\": \\"5.5.3\\",
    \\"prisma\\": \\"3.0.1\\",
    \\"ts-node\\": \\"10.2.1\\",
    \\"typescript\\": \\"4.4.3\\"
  },
  \\"prisma\\": {
    \\"seed\\": \\"ts-node ./prisma/seed.ts\\"
  },
  \\"scripts\\": {
    \\"init\\": \\"prisma db push && prisma db seed\\",
    \\"dev\\": \\"ts-node ./sandbox.ts\\"
  },
  \\"dependencies\\": {
    \\"@prisma/client\\": \\"3.0.1\\"
  },
  \\"engines\\": {
    \\"node\\": \\">=12.2.0\\"
  }
}",
      "path": "package.json",
    },
    "prisma/schema.prisma": Object {
      "content": "// Schema for a fictional hotel
// This hotel tracks rooms, user reservations & reviews

datasource db {
  provider = \\"mysql\\"
  url      = env(\\"DATABASE_URL\\")
}

generator client {
  provider = \\"prisma-client-js\\"
}

model User {
  id           String        @id @default(uuid())
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt
  email        String        @unique
  name         String
  reservations Reservation[]
  reviews      Review[]
}

model Reservation {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  userId    String?
  user      User?    @relation(fields: [userId], references: [id])
  startDate DateTime
  endDate   DateTime
  price     Int
  total     Int
  room      Room?    @relation(fields: [roomId], references: [id])
  roomId    String?
}

model Room {
  id                 String        @id @default(uuid())
  createdAt          DateTime      @default(now())
  updatedAt          DateTime      @updatedAt
  reservations       Reservation[]
  totalOccupancy     Int           @default(5)
  totalBedrooms      Int           @default(5)
  totalBathrooms     Int           @default(5)
  summary            String?
  address            String
  isSmoking          Boolean       @default(false)
  hasTV              Boolean       @default(true)
  hasAirConditioning Boolean       @default(true)
  hasHeating         Boolean       @default(true)
  hasWIFI            Boolean       @default(true)
  price              Int
  media              Media[]
}

model Review {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  rating    Int
  comment   String
  user      User     @relation(fields: [userId], references: [id])
  userId    String
}

model Media {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  room      Room?    @relation(fields: [roomId], references: [id])
  roomId    String?
  fileName  String
}",
      "path": "prisma/schema.prisma",
    },
    "prisma/seed.ts": Object {
      "content": "import { PrismaClient } from '@prisma/client'

import * as faker from 'faker'

const NUMBER_OF_USERS = 10
const NUMBER_OF_ROOMS = 20

const roomIds = Array.from({
  length: NUMBER_OF_ROOMS,
}).map(() => faker.datatype.uuid())

const rooms = Array.from({
  length: NUMBER_OF_ROOMS,
}).map((_, i) => ({
  id: roomIds[i],
  price: faker.datatype.number({
    min: 50,
    max: 600,
  }),
  // random address - example: b-365
  address: \`\${faker.address.streetPrefix()}-\${faker.datatype.number({
    min: 300,
    max: 1,
  })}\`,
  totalOccupancy: faker.datatype.number({ min: 1, max: 5 }),
  totalBedrooms: faker.datatype.number({ min: 1, max: 5 }),
  totalBathrooms: faker.datatype.number({ min: 1, max: 5 }),
  summary: faker.lorem.paragraph(),
  media: Array.from({
    length: faker.datatype.number({ min: 1, max: 5 }),
  }).map(() => ({
    fileName: faker.image.imageUrl(),
  })),
}))

const users = Array.from({ length: NUMBER_OF_USERS }).map(() => ({
  email: faker.internet.email(),
  name: faker.name.firstName(),
  reviews: Array.from({
    length: faker.datatype.number({
      max: 1,
      min: 4,
    }),
  }).map(() => ({
    comment: faker.lorem.paragraph(),
    rating: faker.datatype.number({
      max: 1,
      min: 5,
    }),
  })),
  // create random reservations per user
  reservations: Array.from({
    length: faker.datatype.number({
      min: 1,
      max: 4,
    }),
  }).map(() => {
    const startDate = faker.date.past()
    const endDate = faker.date.future()
    const price = faker.datatype.number({
      min: 50,
      max: 600,
    })
    return {
      startDate,
      endDate,
      price,
      total:
        Math.ceil(Math.abs(+endDate - +startDate) / (1000 * 60 * 60 * 24)) *
        price, // difference between dates * price
      room: {
        connect: {
          id: roomIds[
            faker.datatype.number({
              min: 0,
              max: NUMBER_OF_ROOMS - 1,
            })
          ],
        },
      },
    }
  }),
}))

export async function seed() {
  const prisma = new PrismaClient()

  try {
    for (let room of rooms) {
      await prisma.room.create({
        data: {
          id: room.id,
          address: room.address,
          price: room.price,
          summary: room.summary,
          media: {
            create: room.media,
          },
        },
      })
    }

    for (let user of users) {
      await prisma.user.create({
        data: {
          email: user.email,
          name: user.name,
          reservations: {
            create: user.reservations,
          },
          reviews: {
            create: user.reviews,
          },
        },
      })
    }
  } catch (e) {
    await prisma.$disconnect()
    throw e
  } finally {
    await prisma.$disconnect()
  }
}",
      "path": "prisma/seed.ts",
    },
    "public/index.html": Object {
      "content": "<html>
  <head>
    <title>Rentals Platform Template</title>

    <link rel=\\"icon\\" type=\\"image/svg\\" href=\\"prisma.svg\\" />
    <style>
      @font-face {
        font-family: Inter;
        font-weight: 400;
        src: url('https://cdn.jsdelivr.net/npm/@fontsource/inter/files/inter-latin-400-normal.woff2')
            format('woff2'),
          url('https://cdn.jsdelivr.net/npm/@fontsource/inter/files/inter-latin-400-normal.woff')
            format('woff');
      }

      @font-face {
        font-family: Inter;
        font-weight: 900;
        src: url('https://cdn.jsdelivr.net/npm/@fontsource/inter/files/inter-latin-900-normal.woff2')
            format('woff2'),
          url('https://cdn.jsdelivr.net/npm/@fontsource/inter/files/inter-latin-900-normal.woff')
            format('woff');
      }
    </style>

    <style>
      :root {
        --prisma-blue: #1a202c;
        --white: #ffffff;
        --green: #34d399;
        --black: #000000;
        --gray: rgba(0, 0, 0, 0.75);
      }
    </style>

    <style>
      body {
        margin: 0;
        padding: 0;
        font-size: 16px;
      }
      * {
        box-sizing: border-box;
      }
      h1,
      h2,
      h3,
      h4,
      h5,
      h6,
      p {
        margin: 0;
      }

      #hero {
        background: var(--prisma-blue);
        height: 60%;
        color: var(--white);
        font-family: Inter, sans-serif;
        display: flex;
        flex-direction: column;
        align-items: center;
      }

      #prisma-logo {
        padding: 50px;
      }

      #hero-text {
        display: flex;
        flex-direction: column;
        align-items: center;
        flex: 1;
      }

      #title {
        font-size: 72px;
        font-weight: 900;
        line-height: 1;
        text-align: center;
      }

      #subtitle {
        font-size: 24px;
        font-weight: 400;
        margin: 20px;
        text-align: center;
      }
      #subtitle a {
        color: var(--white) !important;
      }

      #docs {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        margin: 0 auto;
        width: 100%;
        padding: 40px;
      }

      #docs .title {
        color: var(--gray);
        font-family: Inter, sans-serif;
        font-weight: 900;
        margin-bottom: 20px;
      }

      #docs article {
        font-family: monospace;
        margin: 40px;
      }
      #docs article h3 {
        font-family: monospace;
        font-size: 24px;
        color: var(--gray);
        text-align: center;
      }

      #docs article ul {
        list-style: none;
      }

      #docs article ul li {
        display: grid;
        grid-template-columns: 1fr 2fr 3fr;
        margin: 10px;
      }
      #docs article ul li .method {
        color: var(--green);
        text-align: right;
        grid-column: 1 / 2;
        margin-right: 20px;
      }
      #docs article ul li .url {
        color: var(--black);
        grid-column: 2 / 3;
        margin-right: 60px;
      }
      #docs article ul li .description {
        color: var(--gray);
        grid-column: 3 / 4;
      }
    </style>
  </head>

  <body>
    <section id=\\"hero\\">
      <header style=\\"flex: 1\\">
        <img src=\\"prisma.svg\\" alt=\\"Prisma logo\\" id=\\"prisma-logo\\" />
      </header>
      <div id=\\"hero-text\\">
        <h1 id=\\"title\\">Rentals Platform Template</h1>
        <h3 id=\\"subtitle\\">
          Generated by
          <a href=\\"https://cloud.prisma.io\\" target=\\"_blank\\"
            >Prisma Data Platform</a
          >
        </h3>
      </div>
      <div style=\\"flex: 1\\"></div>
    </section>

    <section id=\\"docs\\">
      <h1 class=\\"title\\">API Endpoints</h1>
    </section>

    <script>
      const docs = [
        {
          model: 'User',
          endpoints: [
            {
              method: 'GET',
              url: '/api/users',
              description: 'Get all users',
            },
            {
              method: 'GET',
              url: '/api/users?id=:id',
              description: 'Get a single user',
            },
            {
              method: 'POST',
              url: '/api/usersd',
              description: 'Create a single user',
            },
            {
              method: 'PUT',
              url: '/api/users?id=:id',
              description: 'Update a single user',
            },
            {
              method: 'DELETE',
              url: '/api/users?id=:id',
              description: 'Delete a single user',
            },
          ],
        },
        {
          model: 'Reservation',
          endpoints: [
            {
              method: 'GET',
              url: '/api/reservation',
              description: 'Get all reservation',
            },
            {
              method: 'GET',
              url: '/api/reservation?id=:id',
              description: 'Get a single account',
            },
            {
              method: 'POST',
              url: '/api/reservationd',
              description: 'Create a single account',
            },
            {
              method: 'PUT',
              url: '/api/reservation?id=:id',
              description: 'Update a single account',
            },
            {
              method: 'DELETE',
              url: '/api/reservation?id=:id',
              description: 'Delete a single account',
            },
          ],
        },
        {
          model: 'Room',
          endpoints: [
            {
              method: 'GET',
              url: '/api/room',
              description: 'Get all rooms',
            },
            {
              method: 'GET',
              url: '/api/room?id=:id',
              description: 'Get a single room',
            },
            {
              method: 'POST',
              url: '/api/room',
              description: 'Create a single room',
            },
            {
              method: 'PUT',
              url: '/api/room?id=:id',
              description: 'Update a single room',
            },
            {
              method: 'DELETE',
              url: '/api/room?id=:id',
              description: 'Delete a single room',
            },
          ],
        },
        {
          model: 'Review',
          endpoints: [
            {
              method: 'GET',
              url: '/api/review',
              description: 'Get all reviews',
            },
            {
              method: 'GET',
              url: '/api/review?id=:id',
              description: 'Get a single review',
            },
            {
              method: 'POST',
              url: '/api/review',
              description: 'Create a single review',
            },
            {
              method: 'PUT',
              url: '/api/review?id=:id',
              description: 'Update a single review',
            },
            {
              method: 'DELETE',
              url: '/api/review?id=:id',
              description: 'Delete a single review',
            },
          ],
        },
        {
          model: 'Media',
          endpoints: [
            {
              method: 'GET',
              url: '/api/media',
              description: 'Get all media',
            },
            {
              method: 'GET',
              url: '/api/media?id=:id',
              description: 'Get a single media',
            },
            {
              method: 'POST',
              url: '/api/media',
              description: 'Create a single media',
            },
            {
              method: 'PUT',
              url: '/api/media?id=:id',
              description: 'Update a single media',
            },
            {
              method: 'DELETE',
              url: '/api/media?id=:id',
              description: 'Delete a single media',
            },
          ],
        },
      ]

      // Rendering
      const container = document.getElementById('docs')

      for (const group of docs) {
        const article = document.createElement('article')

        const title = document.createElement('h3')
        title.innerText = group.model
        article.appendChild(title)

        const ul = document.createElement('ul')
        for (const endpoint of group.endpoints) {
          const li = document.createElement('li')
          li.classList.add('endpoint')

          const method = document.createElement('p')
          method.classList.add('method')
          method.innerText = endpoint.method
          li.appendChild(method)

          const url = document.createElement('p')
          url.classList.add('url')
          url.innerText = endpoint.url
          li.appendChild(url)

          const description = document.createElement('p')
          description.classList.add('description')
          description.innerText = endpoint.description
          li.appendChild(description)

          ul.appendChild(li)
        }
        article.appendChild(ul)

        container.appendChild(article)
      }
    </script>
  </body>
</html>",
      "path": "public/index.html",
    },
    "public/prisma.svg": Object {
      "content": "<svg width=\\"32\\" height=\\"40\\" viewBox=\\"0 0 32 40\\" fill=\\"none\\" xmlns=\\"http://www.w3.org/2000/svg\\">
<path fill-rule=\\"evenodd\\" clip-rule=\\"evenodd\\" d=\\"M0.28825 24.9389C-0.101619 25.5764 -0.0955847 26.3808 0.303803 27.0124L7.5326 38.4434C8.00176 39.1853 8.90609 39.5236 9.74539 39.2712L30.606 32.9977C31.7444 32.6554 32.3172 31.3823 31.8196 30.3003L18.4094 1.13932C17.7554 -0.282788 15.7839 -0.399522 14.9675 0.935524L0.28825 24.9389ZM18.1058 7.79741C17.8205 7.13653 16.854 7.23832 16.7124 7.94418L11.5428 33.7038C11.4338 34.247 11.9419 34.7108 12.4724 34.5524L26.9042 30.2411C27.3254 30.1153 27.5424 29.6497 27.368 29.2458L18.1058 7.79741Z\\" fill=\\"white\\"/>
</svg>",
      "path": "public/prisma.svg",
    },
    "sandbox.ts": Object {
      "content": "import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient()

const main = async () => {
  const reservations = await prisma.reservation.findMany({
    where: {
      price: {
        gte: 300,
      },
    },
  })

  console.log('Expensive reservations: ', reservations)
}

main()
  .catch((e) => console.error('Error in Prisma Client query: ', e))
  .finally(async () => await prisma.$disconnect())",
      "path": "sandbox.ts",
    },
    "tsconfig.json": Object {
      "content": "{
  \\"compilerOptions\\": {
    \\"sourceMap\\": true,
    \\"outDir\\": \\"dist\\",
    \\"strict\\": true,
    \\"lib\\": [\\"esnext\\", \\"dom\\"],
    \\"esModuleInterop\\": true
  }
}",
      "path": "tsconfig.json",
    },
  },
  "metadata": Object {
    "displayName": "Rentals Platform",
    "githubUrl": "https://github.com/prisma/prisma-schema-examples/tree/main/rentalsPlatform",
    "name": "rentalsPlatform",
  },
}
`;

exports[`templates can be instantiated with custom datasourceProvider saas 1`] = `
Saas {
  "artifacts": Object {
    "prisma/seed.js": Object {
      "content": "\\"use strict\\";

Object.defineProperty(exports, \\"__esModule\\", {
  value: true
});
exports.seed = seed;

var _studioPcw = require(\\"@prisma/studio-pcw\\");

var faker = _interopRequireWildcard(require(\\"faker\\"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \\"function\\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \\"object\\" && typeof obj !== \\"function\\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \\"default\\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const NUMBER_OF_USERS = 4;
const NUMBER_OF_INVITES = 4;
const data = Array.from({
  length: NUMBER_OF_USERS
}).map(() => ({
  email: faker.internet.email(),
  name: faker.name.firstName(),
  account: {
    stripeCustomerId: faker.datatype.uuid(),
    stripeSubscriptionId: faker.datatype.uuid(),
    isActive: true
  },
  invites: Array.from({
    length: faker.datatype.number({
      min: 0,
      max: NUMBER_OF_INVITES
    })
  }).map(() => ({
    email: faker.internet.email(),
    dateSent: faker.date.future()
  }))
}));
const schema = \`PRISMA TEMPLATE: saas\`;
const schemaPath = \\"/tmp/schema.prisma\\";

async function seed() {
  const pcw = new _studioPcw.PCW(schema, schemaPath, {
    PRISMA_CLOUD_PROJECT_DATASOURCE_URL: process.env.PRISMA_CLOUD_PROJECT_DATASOURCE_URL
  }, {
    forcePrismaLibrary: true,
    resolve: {
      \\".prisma/client\\": require.resolve(\\".prisma/client\\")
    }
  });
  const {
    prisma: prisma
  } = await pcw.getPrismaClient();

  try {
    for (let entry of data) {
      await prisma.user.create({
        data: {
          name: entry.name,
          email: entry.email,
          account: {
            create: {
              stripeCustomerId: entry.account.stripeCustomerId,
              stripeSubscriptionId: entry.account.stripeSubscriptionId,
              isActive: true,
              invites: {
                create: entry.invites
              }
            }
          }
        }
      });
    }
  } catch (e) {
    await prisma.$disconnect();
    throw e;
  } finally {
    await prisma.$disconnect();
  }
}

(async () => await seed())()",
      "path": "prisma/seed.js",
    },
  },
  "files": Object {
    "README.md": Object {
      "content": "# SaaS

Generic Prisma schema example for a SaaS that has a referral system.

![Database diagram](https://raw.githubusercontent.com/prisma/prisma-schema-examples/main/saas/diagram.png)

(Generated via https://github.com/notiz-dev/prisma-dbml-generator + https://dbdiagram.io)

### Setting this project up locally

Once you clone your repo, you'll want to set up this repo for local development. In order to start using Prisma locally, you need to make Prisma aware of your database. The most portable way to do this is to use environment variables via a \`.env\` file.

1. You'll see that your Prisma Schema file (at \`prisma/schema.prisma\`) is already configured to use an environment variable called \`DATABASE_URL\`. [Read more about environment variables in Prisma](https://www.prisma.io/docs/concepts/more/environment-variables)
2. You'll need a database to connect to. You may use the same one you used while setting this project up on the Prisma Data Platform, but we recommend setting up a local database and use that during development. If you're new to databases, we recommend [reading up](https://www.prisma.io/dataguide/) on them. This guide also has instructions on how to set up a local database.
3. Once you have a locally accessible database connection string, create a new file called \`.env\` in the \`prisma\` directory, and populate it with: \`DATABASE_URL=\\"<replace-me-with-your-connection-string>\\"\`. Prisma will automatically pick up the environment variable used in the schema and use its value to connect to your database.
4. Now you can run \`npm run init\` to set up your local database. This will create tables corresponding to models in your Prisma Schema and populate them with fake data for you to play around with.
   - [Read more about the Prisma Schema](https://www.prisma.io/docs/concepts/components/prisma-schema)
   - [Read more about database seeding](https://www.prisma.io/docs/guides/database/seed-database)

To learn more about Prisma, we recommend reading through our [Getting Started guide](https://www.prisma.io/docs/getting-started)",
      "path": "README.md",
    },
    "api/account.ts": Object {
      "content": "import { PrismaClient, Prisma } from '@prisma/client'
import { VercelRequest, VercelResponse } from '@vercel/node'

type VercelRequestQuery = {
  id?: string
}

export default async function (req: VercelRequest, res: VercelResponse) {
  try {
    const { id } = req.query as VercelRequestQuery
    const prisma = new PrismaClient()

    console.log(
      '[account] Incoming request:',
      JSON.stringify(
        {
          method: req.method,
          query: req.query,
          body: req.body,
        },
        null,
        2,
      ),
    )

    switch (req.method) {
      case 'GET':
        return res.json(
          await prisma.account.findMany({
            where: { id },
          }),
        )
      case 'POST':
        return res.json(
          await prisma.account.create({
            data: req.body as Prisma.AccountCreateInput,
          }),
        )
      case 'PUT':
        return res.json(
          await prisma.account.update({
            where: {
              id,
            },
            data: req.body as Prisma.AccountUpdateInput,
          }),
        )
      case 'DELETE':
        return res.json(
          await prisma.account.delete({
            where: { id },
          }),
        )
    }

    return res
      .status(400)
      .send({ message: \`Unexpected request method: \${req.method}\` })
  } catch (e: any) {
    console.error('[account] Error responding:', e)
    return res.status(500).json({ message: e?.message || e })
  }
}",
      "path": "api/account.ts",
    },
    "api/invite.ts": Object {
      "content": "import { PrismaClient, Prisma } from '@prisma/client'
import { VercelRequest, VercelResponse } from '@vercel/node'

type VercelRequestQuery = {
  id?: string
}

export default async function (req: VercelRequest, res: VercelResponse) {
  try {
    const { id } = req.query as VercelRequestQuery
    const prisma = new PrismaClient()

    console.log(
      '[invite] Incoming request:',
      JSON.stringify(
        {
          method: req.method,
          query: req.query,
          body: req.body,
        },
        null,
        2,
      ),
    )

    switch (req.method) {
      case 'GET':
        return res.json(
          await prisma.invite.findMany({
            where: { id },
          }),
        )
      case 'POST':
        return res.json(
          await prisma.invite.create({
            data: req.body as Prisma.InviteCreateInput,
          }),
        )
      case 'PUT':
        return res.json(
          await prisma.invite.update({
            where: {
              id,
            },
            data: req.body as Prisma.InviteUpdateInput,
          }),
        )
      case 'DELETE':
        return res.json(
          await prisma.invite.delete({
            where: { id },
          }),
        )
    }

    return res
      .status(400)
      .send({ message: \`Unexpected request method: \${req.method}\` })
  } catch (e: any) {
    console.error('[invite] Error responding:', e)
    return res.status(500).json({ message: e?.message || e })
  }
}",
      "path": "api/invite.ts",
    },
    "api/user.ts": Object {
      "content": "import { PrismaClient, Prisma } from '@prisma/client'
import { VercelRequest, VercelResponse } from '@vercel/node'

type VercelRequestQuery = {
  id?: string
}

export default async function (req: VercelRequest, res: VercelResponse) {
  try {
    const { id } = req.query as VercelRequestQuery
    const prisma = new PrismaClient()

    console.log(
      '[user] Incoming request:',
      JSON.stringify(
        {
          method: req.method,
          query: req.query,
          body: req.body,
        },
        null,
        2,
      ),
    )

    switch (req.method) {
      case 'GET':
        return res.json(
          await prisma.user.findMany({
            where: { id },
          }),
        )
      case 'POST':
        return res.json(
          await prisma.user.create({
            data: req.body as Prisma.UserCreateInput,
          }),
        )
      case 'PUT':
        return res.json(
          await prisma.user.update({
            where: {
              id,
            },
            data: req.body as Prisma.UserUpdateInput,
          }),
        )
      case 'DELETE':
        return res.json(
          await prisma.user.delete({
            where: { id },
          }),
        )
    }

    return res
      .status(400)
      .send({ message: \`Unexpected request method: \${req.method}\` })
  } catch (e: any) {
    console.error('[user] Error responding:', e)
    return res.status(500).json({ message: e?.message || e })
  }
}",
      "path": "api/user.ts",
    },
    "package.json": Object {
      "content": "{
  \\"name\\": \\"saas\\",
  \\"license\\": \\"UNLICENSED\\",
  \\"devDependencies\\": {
    \\"@types/faker\\": \\"5.5.8\\",
    \\"@types/node\\": \\"16.9.6\\",
    \\"@vercel/node\\": \\"1.12.1\\",
    \\"faker\\": \\"5.5.3\\",
    \\"prisma\\": \\"3.0.1\\",
    \\"ts-node\\": \\"10.2.1\\",
    \\"typescript\\": \\"4.4.3\\"
  },
  \\"prisma\\": {
    \\"seed\\": \\"ts-node ./prisma/seed.ts\\"
  },
  \\"scripts\\": {
    \\"init\\": \\"prisma db push && prisma db seed\\",
    \\"dev\\": \\"ts-node ./sandbox.ts\\"
  },
  \\"dependencies\\": {
    \\"@prisma/client\\": \\"3.0.1\\"
  },
  \\"engines\\": {
    \\"node\\": \\">=12.2.0\\"
  }
}",
      "path": "package.json",
    },
    "prisma/schema.prisma": Object {
      "content": "// Schema for an identity service for a SaaS
// This service tracks existing users & their accounts, as well as invites for users who haven't joined yet

datasource db {
  provider = \\"mysql\\"
  url      = env(\\"DATABASE_URL\\")
}

generator client {
  provider = \\"prisma-client-js\\"
}

model User {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  name      String?
  email     String
  account   Account? @relation(fields: [accountId], references: [id])
  accountId String?
}

model Account {
  id                   String   @id @default(uuid())
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt
  invites              Invite[]
  users                User[]
  stripeCustomerId     String
  stripeSubscriptionId String
  referrer             String?
  isActive             Boolean
}

model Invite {
  id        String   @id @default(uuid())
  dateSent  DateTime @default(now())
  email     String
  account   Account? @relation(fields: [accountId], references: [id])
  accountId String?
  isValid   Boolean  @default(true)
}",
      "path": "prisma/schema.prisma",
    },
    "prisma/seed.ts": Object {
      "content": "import { PrismaClient } from '@prisma/client'
import * as faker from 'faker'

const NUMBER_OF_USERS = 4
const NUMBER_OF_INVITES = 4

const data = Array.from({ length: NUMBER_OF_USERS }).map(() => ({
  email: faker.internet.email(),
  name: faker.name.firstName(),
  account: {
    stripeCustomerId: faker.datatype.uuid(),
    stripeSubscriptionId: faker.datatype.uuid(),
    isActive: true,
  },
  invites: Array.from({
    length: faker.datatype.number({ min: 0, max: NUMBER_OF_INVITES }),
  }).map(() => ({
    email: faker.internet.email(),
    dateSent: faker.date.future(),
  })),
}))

export async function seed() {
  const prisma = new PrismaClient()

  try {
    for (let entry of data) {
      await prisma.user.create({
        data: {
          name: entry.name,
          email: entry.email,
          account: {
            create: {
              stripeCustomerId: entry.account.stripeCustomerId,
              stripeSubscriptionId: entry.account.stripeSubscriptionId,
              isActive: true,
              invites: {
                create: entry.invites,
              },
            },
          },
        },
      })
    }
  } catch (e) {
    await prisma.$disconnect()
    throw e
  } finally {
    await prisma.$disconnect()
  }
}",
      "path": "prisma/seed.ts",
    },
    "public/index.html": Object {
      "content": "<html>
  <head>
    <title>SaaS Template</title>

    <link rel=\\"icon\\" type=\\"image/svg\\" href=\\"prisma.svg\\" />
    <style>
      @font-face {
        font-family: Inter;
        font-weight: 400;
        src: url('https://cdn.jsdelivr.net/npm/@fontsource/inter/files/inter-latin-400-normal.woff2')
            format('woff2'),
          url('https://cdn.jsdelivr.net/npm/@fontsource/inter/files/inter-latin-400-normal.woff')
            format('woff');
      }

      @font-face {
        font-family: Inter;
        font-weight: 900;
        src: url('https://cdn.jsdelivr.net/npm/@fontsource/inter/files/inter-latin-900-normal.woff2')
            format('woff2'),
          url('https://cdn.jsdelivr.net/npm/@fontsource/inter/files/inter-latin-900-normal.woff')
            format('woff');
      }
    </style>

    <style>
      :root {
        --prisma-blue: #1a202c;
        --white: #ffffff;
        --green: #34d399;
        --black: #000000;
        --gray: rgba(0, 0, 0, 0.75);
      }
    </style>

    <style>
      body {
        margin: 0;
        padding: 0;
        font-size: 16px;
      }
      * {
        box-sizing: border-box;
      }
      h1,
      h2,
      h3,
      h4,
      h5,
      h6,
      p {
        margin: 0;
      }

      #hero {
        background: var(--prisma-blue);
        height: 60%;
        color: var(--white);
        font-family: Inter, sans-serif;
        display: flex;
        flex-direction: column;
        align-items: center;
      }

      #prisma-logo {
        padding: 50px;
      }

      #hero-text {
        display: flex;
        flex-direction: column;
        align-items: center;
        flex: 1;
      }

      #title {
        font-size: 72px;
        font-weight: 900;
        line-height: 1;
      }

      #subtitle {
        font-size: 24px;
        font-weight: 400;
        margin: 20px;
      }
      #subtitle a {
        color: var(--white) !important;
      }

      #docs {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        margin: 0 auto;
        width: 100%;
        padding: 40px;
      }

      #docs .title {
        color: var(--gray);
        font-family: Inter, sans-serif;
        font-weight: 900;
        margin-bottom: 20px;
      }

      #docs article {
        font-family: monospace;
        margin: 40px;
      }
      #docs article h3 {
        font-family: monospace;
        font-size: 24px;
        color: var(--gray);
        text-align: center;
      }

      #docs article ul {
        list-style: none;
      }

      #docs article ul li {
        display: grid;
        grid-template-columns: 1fr 2fr 3fr;
        margin: 10px;
      }
      #docs article ul li .method {
        color: var(--green);
        text-align: right;
        grid-column: 1 / 2;
        margin-right: 20px;
      }
      #docs article ul li .url {
        color: var(--black);
        grid-column: 2 / 3;
        margin-right: 60px;
      }
      #docs article ul li .description {
        color: var(--gray);
        grid-column: 3 / 4;
      }
    </style>
  </head>

  <body>
    <section id=\\"hero\\">
      <header style=\\"flex: 1\\">
        <img src=\\"prisma.svg\\" alt=\\"Prisma logo\\" id=\\"prisma-logo\\" />
      </header>
      <div id=\\"hero-text\\">
        <h1 id=\\"title\\">SaaS Template</h1>
        <h3 id=\\"subtitle\\">
          Generated by
          <a href=\\"https://cloud.prisma.io\\" target=\\"_blank\\"
            >Prisma Data Platform</a
          >
        </h3>
      </div>
      <div style=\\"flex: 1\\"></div>
    </section>

    <section id=\\"docs\\">
      <h1 class=\\"title\\">API Endpoints</h1>
    </section>

    <script>
      const docs = [
        {
          model: 'User',
          endpoints: [
            {
              method: 'GET',
              url: '/api/user',
              description: 'Get all users',
            },
            {
              method: 'GET',
              url: '/api/user?id=:id',
              description: 'Get a single user',
            },
            {
              method: 'POST',
              url: '/api/userd',
              description: 'Create a single user',
            },
            {
              method: 'PUT',
              url: '/api/user?id=:id',
              description: 'Update a single user',
            },
            {
              method: 'DELETE',
              url: '/api/user?id=:id',
              description: 'Delete a single user',
            },
          ],
        },
        {
          model: 'Account',
          endpoints: [
            {
              method: 'GET',
              url: '/api/account',
              description: 'Get all accounts',
            },
            {
              method: 'GET',
              url: '/api/account?id=:id',
              description: 'Get a single account',
            },
            {
              method: 'POST',
              url: '/api/accountd',
              description: 'Create a single account',
            },
            {
              method: 'PUT',
              url: '/api/account?id=:id',
              description: 'Update a single account',
            },
            {
              method: 'DELETE',
              url: '/api/account?id=:id',
              description: 'Delete a single account',
            },
          ],
        },
        {
          model: 'Invite',
          endpoints: [
            {
              method: 'GET',
              url: '/api/invite',
              description: 'Get all invites',
            },
            {
              method: 'GET',
              url: '/api/invite?id=:id',
              description: 'Get a single invite',
            },
            {
              method: 'POST',
              url: '/api/invited',
              description: 'Create a single invite',
            },
            {
              method: 'PUT',
              url: '/api/invite?id=:id',
              description: 'Update a single invite',
            },
            {
              method: 'DELETE',
              url: '/api/invite?id=:id',
              description: 'Delete a single invite',
            },
          ],
        },
      ]

      // Rendering
      const container = document.getElementById('docs')

      for (const group of docs) {
        const article = document.createElement('article')

        const title = document.createElement('h3')
        title.innerText = group.model
        article.appendChild(title)

        const ul = document.createElement('ul')
        for (const endpoint of group.endpoints) {
          const li = document.createElement('li')
          li.classList.add('endpoint')

          const method = document.createElement('p')
          method.classList.add('method')
          method.innerText = endpoint.method
          li.appendChild(method)

          const url = document.createElement('p')
          url.classList.add('url')
          url.innerText = endpoint.url
          li.appendChild(url)

          const description = document.createElement('p')
          description.classList.add('description')
          description.innerText = endpoint.description
          li.appendChild(description)

          ul.appendChild(li)
        }
        article.appendChild(ul)

        container.appendChild(article)
      }
    </script>
  </body>
</html>",
      "path": "public/index.html",
    },
    "public/prisma.svg": Object {
      "content": "<svg width=\\"32\\" height=\\"40\\" viewBox=\\"0 0 32 40\\" fill=\\"none\\" xmlns=\\"http://www.w3.org/2000/svg\\">
<path fill-rule=\\"evenodd\\" clip-rule=\\"evenodd\\" d=\\"M0.28825 24.9389C-0.101619 25.5764 -0.0955847 26.3808 0.303803 27.0124L7.5326 38.4434C8.00176 39.1853 8.90609 39.5236 9.74539 39.2712L30.606 32.9977C31.7444 32.6554 32.3172 31.3823 31.8196 30.3003L18.4094 1.13932C17.7554 -0.282788 15.7839 -0.399522 14.9675 0.935524L0.28825 24.9389ZM18.1058 7.79741C17.8205 7.13653 16.854 7.23832 16.7124 7.94418L11.5428 33.7038C11.4338 34.247 11.9419 34.7108 12.4724 34.5524L26.9042 30.2411C27.3254 30.1153 27.5424 29.6497 27.368 29.2458L18.1058 7.79741Z\\" fill=\\"white\\"/>
</svg>",
      "path": "public/prisma.svg",
    },
    "sandbox.ts": Object {
      "content": "import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient()

const main = async () => {
  const accounts = await prisma.account.findMany({
    where: {
      isActive: true,
    },
  })

  console.log('Premium accounts: ', accounts)
}

main()
  .catch((e) => console.error('Error in Prisma Client query: ', e))
  .finally(async () => await prisma.$disconnect())",
      "path": "sandbox.ts",
    },
    "tsconfig.json": Object {
      "content": "{
  \\"compilerOptions\\": {
    \\"sourceMap\\": true,
    \\"outDir\\": \\"dist\\",
    \\"strict\\": true,
    \\"lib\\": [\\"esnext\\", \\"dom\\"],
    \\"esModuleInterop\\": true
  }
}",
      "path": "tsconfig.json",
    },
  },
  "metadata": Object {
    "displayName": "Saas",
    "githubUrl": "https://github.com/prisma/prisma-schema-examples/tree/main/saas",
    "name": "saas",
  },
}
`;

exports[`templates can be instantiated with custom datasourceProvider urlShortener 1`] = `
UrlShortener {
  "artifacts": Object {
    "prisma/seed.js": Object {
      "content": "\\"use strict\\";

Object.defineProperty(exports, \\"__esModule\\", {
  value: true
});
exports.seed = seed;

var _studioPcw = require(\\"@prisma/studio-pcw\\");

var faker = _interopRequireWildcard(require(\\"faker\\"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \\"function\\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \\"object\\" && typeof obj !== \\"function\\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \\"default\\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const NUMBER_OF_USERS = 4;
const MAX_NUMBER_OF_LINKS = 5;
const data = Array.from({
  length: NUMBER_OF_USERS
}).map(() => ({
  email: faker.internet.email(),
  name: faker.name.firstName(),
  links: Array.from({
    length: faker.datatype.number({
      min: 0,
      max: MAX_NUMBER_OF_LINKS
    })
  }).map(() => ({
    url: faker.internet.url(),
    shortUrl: faker.internet.domainWord()
  }))
}));
const schema = \`PRISMA TEMPLATE: urlShortener\`;
const schemaPath = \\"/tmp/schema.prisma\\";

async function seed() {
  const pcw = new _studioPcw.PCW(schema, schemaPath, {
    PRISMA_CLOUD_PROJECT_DATASOURCE_URL: process.env.PRISMA_CLOUD_PROJECT_DATASOURCE_URL
  }, {
    forcePrismaLibrary: true,
    resolve: {
      \\".prisma/client\\": require.resolve(\\".prisma/client\\")
    }
  });
  const {
    prisma: prisma
  } = await pcw.getPrismaClient();

  try {
    for (let entry of data) {
      await prisma.user.create({
        data: {
          name: entry.name,
          email: entry.email,
          links: {
            create: entry.links
          }
        }
      });
    }
  } catch (e) {
    await prisma.$disconnect();
    throw e;
  } finally {
    await prisma.$disconnect();
  }
}

(async () => await seed())()",
      "path": "prisma/seed.js",
    },
  },
  "files": Object {
    "README.md": Object {
      "content": "# URL Shortener

![Database diagram](https://raw.githubusercontent.com/prisma/prisma-schema-examples/main/urlShortener/diagram.png)

(Generated via https://github.com/notiz-dev/prisma-dbml-generator + https://dbdiagram.io)

### Setting this project up locally

Once you clone your repo, you'll want to set up this repo for local development. In order to start using Prisma locally, you need to make Prisma aware of your database. The most portable way to do this is to use environment variables via a \`.env\` file.

1. You'll see that your Prisma Schema file (at \`prisma/schema.prisma\`) is already configured to use an environment variable called \`DATABASE_URL\`. [Read more about environment variables in Prisma](https://www.prisma.io/docs/concepts/more/environment-variables)
2. You'll need a database to connect to. You may use the same one you used while setting this project up on the Prisma Data Platform, but we recommend setting up a local database and use that during development. If you're new to databases, we recommend [reading up](https://www.prisma.io/dataguide/) on them. This guide also has instructions on how to set up a local database.
3. Once you have a locally accessible database connection string, create a new file called \`.env\` in the \`prisma\` directory, and populate it with: \`DATABASE_URL=\\"<replace-me-with-your-connection-string>\\"\`. Prisma will automatically pick up the environment variable used in the schema and use its value to connect to your database.
4. Now you can run \`npm run init\` to set up your local database. This will create tables corresponding to models in your Prisma Schema and populate them with fake data for you to play around with.
   - [Read more about the Prisma Schema](https://www.prisma.io/docs/concepts/components/prisma-schema)
   - [Read more about database seeding](https://www.prisma.io/docs/guides/database/seed-database)

To learn more about Prisma, we recommend reading through our [Getting Started guide](https://www.prisma.io/docs/getting-started)",
      "path": "README.md",
    },
    "api/link.ts": Object {
      "content": "import { PrismaClient, Prisma } from '@prisma/client'
import { VercelRequest, VercelResponse } from '@vercel/node'

type VercelRequestQuery = {
  id?: string
}

export default async function (req: VercelRequest, res: VercelResponse) {
  try {
    const { id } = req.query as VercelRequestQuery
    const prisma = new PrismaClient()

    console.log(
      '[link] Incoming request:',
      JSON.stringify(
        {
          method: req.method,
          query: req.query,
          body: req.body,
        },
        null,
        2,
      ),
    )

    switch (req.method) {
      case 'GET':
        return res.json(
          await prisma.link.findMany({
            where: { id },
          }),
        )
      case 'POST':
        return res.json(
          await prisma.link.create({
            data: req.body as Prisma.LinkCreateInput,
          }),
        )
      case 'PUT':
        return res.json(
          await prisma.link.update({
            where: {
              id,
            },
            data: req.body as Prisma.LinkUpdateInput,
          }),
        )
      case 'DELETE':
        return res.json(
          await prisma.link.delete({
            where: { id },
          }),
        )
    }

    return res
      .status(400)
      .send({ message: \`Unexpected request method: \${req.method}\` })
  } catch (e: any) {
    console.error('[link] Error responding:', e)
    return res.status(500).json({ message: e?.message || e })
  }
}",
      "path": "api/link.ts",
    },
    "api/user.ts": Object {
      "content": "import { PrismaClient, Prisma } from '@prisma/client'
import { VercelRequest, VercelResponse } from '@vercel/node'

type VercelRequestQuery = {
  id?: string
}

export default async function (req: VercelRequest, res: VercelResponse) {
  try {
    const { id } = req.query as VercelRequestQuery
    const prisma = new PrismaClient()

    console.log(
      '[user] Incoming request:',
      JSON.stringify(
        {
          method: req.method,
          query: req.query,
          body: req.body,
        },
        null,
        2,
      ),
    )

    switch (req.method) {
      case 'GET':
        return res.json(
          await prisma.user.findMany({
            where: { id },
          }),
        )
      case 'POST':
        return res.json(
          await prisma.user.create({
            data: req.body as Prisma.UserCreateInput,
          }),
        )
      case 'PUT':
        return res.json(
          await prisma.user.update({
            where: {
              id,
            },
            data: req.body as Prisma.UserUpdateInput,
          }),
        )
      case 'DELETE':
        return res.json(
          await prisma.user.delete({
            where: { id },
          }),
        )
    }

    return res
      .status(400)
      .send({ message: \`Unexpected request method: \${req.method}\` })
  } catch (e: any) {
    console.error('[user] Error responding:', e)
    return res.status(500).json({ message: e?.message || e })
  }
}",
      "path": "api/user.ts",
    },
    "package.json": Object {
      "content": "{
  \\"name\\": \\"url-shortener\\",
  \\"license\\": \\"UNLICENSED\\",
  \\"devDependencies\\": {
    \\"@types/faker\\": \\"5.5.8\\",
    \\"@types/node\\": \\"16.9.6\\",
    \\"@vercel/node\\": \\"1.12.1\\",
    \\"faker\\": \\"5.5.3\\",
    \\"prisma\\": \\"3.0.1\\",
    \\"ts-node\\": \\"10.2.1\\",
    \\"typescript\\": \\"4.4.3\\"
  },
  \\"prisma\\": {
    \\"seed\\": \\"ts-node prisma/seed\\"
  },
  \\"scripts\\": {
    \\"init\\": \\"prisma db push && prisma db seed\\",
    \\"dev\\": \\"ts-node ./sandbox.ts\\"
  },
  \\"dependencies\\": {
    \\"@prisma/client\\": \\"3.0.1\\"
  },
  \\"engines\\": {
    \\"node\\": \\">=12.2.0\\"
  }
}",
      "path": "package.json",
    },
    "prisma/schema.prisma": Object {
      "content": "// Schema for a simple URL shortener
// This schema tracks short links by associating them to a user

datasource db {
  provider = \\"mysql\\"
  url      = env(\\"DATABASE_URL\\")
}

generator client {
  provider = \\"prisma-client-js\\"
}

model Link {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  url       String
  shortUrl  String
  User      User?    @relation(fields: [userId], references: [id])
  userId    String?
}

model User {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  name      String?
  email     String
  links     Link[]
}",
      "path": "prisma/schema.prisma",
    },
    "prisma/seed.ts": Object {
      "content": "import { PrismaClient } from '@prisma/client'
import * as faker from 'faker'

const NUMBER_OF_USERS = 4
const MAX_NUMBER_OF_LINKS = 5

const data = Array.from({ length: NUMBER_OF_USERS }).map(() => ({
  email: faker.internet.email(),
  name: faker.name.firstName(),
  links: Array.from({
    length: faker.datatype.number({
      min: 0,
      max: MAX_NUMBER_OF_LINKS,
    }),
  }).map(() => ({
    url: faker.internet.url(),
    shortUrl: faker.internet.domainWord(),
  })),
}))

export async function seed() {
  const prisma = new PrismaClient()

  try {
    for (let entry of data) {
      await prisma.user.create({
        data: {
          name: entry.name,
          email: entry.email,
          links: {
            create: entry.links,
          },
        },
      })
    }
  } catch (e) {
    await prisma.$disconnect()
    throw e
  } finally {
    await prisma.$disconnect()
  }
}",
      "path": "prisma/seed.ts",
    },
    "public/index.html": Object {
      "content": "<html>
  <head>
    <title>URL Shortener Template</title>

    <link rel=\\"icon\\" type=\\"image/svg\\" href=\\"prisma.svg\\" />
    <style>
      @font-face {
        font-family: Inter;
        font-weight: 400;
        src: url('https://cdn.jsdelivr.net/npm/@fontsource/inter/files/inter-latin-400-normal.woff2')
            format('woff2'),
          url('https://cdn.jsdelivr.net/npm/@fontsource/inter/files/inter-latin-400-normal.woff')
            format('woff');
      }

      @font-face {
        font-family: Inter;
        font-weight: 900;
        src: url('https://cdn.jsdelivr.net/npm/@fontsource/inter/files/inter-latin-900-normal.woff2')
            format('woff2'),
          url('https://cdn.jsdelivr.net/npm/@fontsource/inter/files/inter-latin-900-normal.woff')
            format('woff');
      }
    </style>

    <style>
      :root {
        --prisma-blue: #1a202c;
        --white: #ffffff;
        --green: #34d399;
        --black: #000000;
        --gray: rgba(0, 0, 0, 0.75);
      }
    </style>

    <style>
      body {
        margin: 0;
        padding: 0;
        font-size: 16px;
      }
      * {
        box-sizing: border-box;
      }
      h1,
      h2,
      h3,
      h4,
      h5,
      h6,
      p {
        margin: 0;
      }

      #hero {
        background: var(--prisma-blue);
        height: 60%;
        color: var(--white);
        font-family: Inter, sans-serif;
        display: flex;
        flex-direction: column;
        align-items: center;
      }

      #prisma-logo {
        padding: 50px;
      }

      #hero-text {
        display: flex;
        flex-direction: column;
        align-items: center;
        flex: 1;
      }

      #title {
        font-size: 72px;
        font-weight: 900;
        line-height: 1;
      }

      #subtitle {
        font-size: 24px;
        font-weight: 400;
        margin: 20px;
      }
      #subtitle a {
        color: var(--white) !important;
      }

      #docs {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        margin: 0 auto;
        width: 100%;
        padding: 40px;
      }

      #docs .title {
        color: var(--gray);
        font-family: Inter, sans-serif;
        font-weight: 900;
        margin-bottom: 20px;
      }

      #docs article {
        font-family: monospace;
        margin: 40px;
      }
      #docs article h3 {
        font-family: monospace;
        font-size: 24px;
        color: var(--gray);
        text-align: center;
      }

      #docs article ul {
        list-style: none;
      }

      #docs article ul li {
        display: grid;
        grid-template-columns: 1fr 2fr 3fr;
        margin: 10px;
      }
      #docs article ul li .method {
        color: var(--green);
        text-align: right;
        grid-column: 1 / 2;
        margin-right: 20px;
      }
      #docs article ul li .url {
        color: var(--black);
        grid-column: 2 / 3;
        margin-right: 60px;
      }
      #docs article ul li .description {
        color: var(--gray);
        grid-column: 3 / 4;
      }
    </style>
  </head>

  <body>
    <section id=\\"hero\\">
      <header style=\\"flex: 1\\">
        <img src=\\"prisma.svg\\" alt=\\"Prisma logo\\" id=\\"prisma-logo\\" />
      </header>
      <div id=\\"hero-text\\">
        <h1 id=\\"title\\">URL Shortener Template</h1>
        <h3 id=\\"subtitle\\">
          Generated by
          <a href=\\"https://cloud.prisma.io\\" target=\\"_blank\\"
            >Prisma Data Platform</a
          >
        </h3>
      </div>
      <div style=\\"flex: 1\\"></div>
    </section>

    <section id=\\"docs\\">
      <h1 class=\\"title\\">API Endpoints</h1>
    </section>

    <script>
      const docs = [
        {
          model: 'User',
          endpoints: [
            {
              method: 'GET',
              url: '/api/user',
              description: 'Get all users',
            },
            {
              method: 'GET',
              url: '/api/user?id=:id',
              description: 'Get a single user',
            },
            {
              method: 'POST',
              url: '/api/userd',
              description: 'Create a single user',
            },
            {
              method: 'PUT',
              url: '/api/user?id=:id',
              description: 'Update a single user',
            },
            {
              method: 'DELETE',
              url: '/api/user?id=:id',
              description: 'Delete a single user',
            },
          ],
        },
        {
          model: 'Link',
          endpoints: [
            {
              method: 'GET',
              url: '/api/link',
              description: 'Get all links',
            },
            {
              method: 'GET',
              url: '/api/link?id=:id',
              description: 'Get a single link',
            },
            {
              method: 'POST',
              url: '/api/link',
              description: 'Create a single link',
            },
            {
              method: 'PUT',
              url: '/api/link?id=:id',
              description: 'Update a single link',
            },
            {
              method: 'DELETE',
              url: '/api/link?id=:id',
              description: 'Delete a single link',
            },
          ],
        },
      ]

      // Rendering
      const container = document.getElementById('docs')

      for (const group of docs) {
        const article = document.createElement('article')

        const title = document.createElement('h3')
        title.innerText = group.model
        article.appendChild(title)

        const ul = document.createElement('ul')
        for (const endpoint of group.endpoints) {
          const li = document.createElement('li')
          li.classList.add('endpoint')

          const method = document.createElement('p')
          method.classList.add('method')
          method.innerText = endpoint.method
          li.appendChild(method)

          const url = document.createElement('p')
          url.classList.add('url')
          url.innerText = endpoint.url
          li.appendChild(url)

          const description = document.createElement('p')
          description.classList.add('description')
          description.innerText = endpoint.description
          li.appendChild(description)

          ul.appendChild(li)
        }
        article.appendChild(ul)

        container.appendChild(article)
      }
    </script>
  </body>
</html>",
      "path": "public/index.html",
    },
    "public/prisma.svg": Object {
      "content": "<svg width=\\"32\\" height=\\"40\\" viewBox=\\"0 0 32 40\\" fill=\\"none\\" xmlns=\\"http://www.w3.org/2000/svg\\">
<path fill-rule=\\"evenodd\\" clip-rule=\\"evenodd\\" d=\\"M0.28825 24.9389C-0.101619 25.5764 -0.0955847 26.3808 0.303803 27.0124L7.5326 38.4434C8.00176 39.1853 8.90609 39.5236 9.74539 39.2712L30.606 32.9977C31.7444 32.6554 32.3172 31.3823 31.8196 30.3003L18.4094 1.13932C17.7554 -0.282788 15.7839 -0.399522 14.9675 0.935524L0.28825 24.9389ZM18.1058 7.79741C17.8205 7.13653 16.854 7.23832 16.7124 7.94418L11.5428 33.7038C11.4338 34.247 11.9419 34.7108 12.4724 34.5524L26.9042 30.2411C27.3254 30.1153 27.5424 29.6497 27.368 29.2458L18.1058 7.79741Z\\" fill=\\"white\\"/>
</svg>",
      "path": "public/prisma.svg",
    },
    "sandbox.ts": Object {
      "content": "import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient()

const main = async () => {
  const users = await prisma.user.findMany({
    where: {
      name: {
        startsWith: 'A',
      },
    },
  })

  console.log('Top users (alphabetical): ', users)
}

main()
  .catch((e) => console.error('Error in Prisma Client query: ', e))
  .finally(async () => await prisma.$disconnect())",
      "path": "sandbox.ts",
    },
    "tsconfig.json": Object {
      "content": "{
  \\"compilerOptions\\": {
    \\"sourceMap\\": true,
    \\"outDir\\": \\"dist\\",
    \\"strict\\": true,
    \\"lib\\": [\\"esnext\\", \\"dom\\"],
    \\"esModuleInterop\\": true
  }
}",
      "path": "tsconfig.json",
    },
  },
  "metadata": Object {
    "displayName": "Url Shortener",
    "githubUrl": "https://github.com/prisma/prisma-schema-examples/tree/main/urlShortener",
    "name": "urlShortener",
  },
}
`;
